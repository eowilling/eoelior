<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script>
        // 自動檢測設備類型並設定 viewport
        (function () {
            try {
                const KEY = 'eveday_force_desktop';
                const TARGET_WIDTH = 1280;
                const meta = document.querySelector('meta[name="viewport"]');
                if (!meta) return;

                // 檢測是否為移動設備（結合 User Agent 和觸控支援）
                function isMobileDevice() {
                    const ua = navigator.userAgent.toLowerCase();
                    const mobileUA = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(ua);
                    const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                    const isSmallScreen = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
                    // 移動設備：小螢幕且（有移動 UA 或支援觸控）
                    return isSmallScreen && (mobileUA || hasTouch);
                }

                const isMobile = isMobileDevice();
                const userForceDesktop = localStorage.getItem(KEY) === 'true';

                // 如果用戶手動選擇桌機模式，使用桌機視覺
                if (userForceDesktop) {
                    const scale = Math.max(0.25, Math.min(1, window.innerWidth / TARGET_WIDTH));
                    meta.setAttribute('content', `width=${TARGET_WIDTH}, initial-scale=${scale}, viewport-fit=cover`);
                    document.documentElement.classList.add('eveday-force-desktop');
                } else {
                    // 自動判斷：根據設備類型使用對應的 viewport
                    if (isMobile) {
                        meta.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes');
                        document.documentElement.classList.add('is-mobile');
                    } else {
                        meta.setAttribute('content', 'width=device-width, initial-scale=1.0');
                        document.documentElement.classList.add('is-desktop');
                    }
                }
            } catch (_) {
                // ignore errors
            }
        })();
    </script>
    <title>待辦事項日曆</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .calendar-day {
            min-height: 100px;
            transition: all 0.2s;
        }
        .calendar-day:hover {
            background-color: #f3f4f6;
        }
        .calendar-day.has-todos {
            background-color: #fef3c7;
        }
        .todo-item {
            transition: all 0.2s;
        }
        .todo-item:hover {
            background-color: #f9fafb;
        }
        .todo-item.completed {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border-color: #10b981;
        }
        .todo-item.completed:hover {
            background: linear-gradient(135deg, #a7f3d0 0%, #6ee7b7 100%);
        }
        .todo-item.failed {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            border-color: #9ca3af;
            opacity: 0.7;
        }
        .todo-item.failed:hover {
            background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 100%);
        }

        /* 手機版保持正常大小 */
        @media (max-width: 900px) {
            html:not(.eveday-force-desktop) body {
                overflow-x: hidden;
            }
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="evedayNav"></div>
    <div id="evedayAppRoot" class="min-h-screen p-4 md:p-8">
        <div class="max-w-7xl mx-auto">
        <!-- Header -->
            <header class="mb-8">
                <div class="flex flex-col gap-4 lg:flex-row lg:justify-between lg:items-start mb-4">
                    <div>
                        <h1 class="text-3xl sm:text-4xl font-bold text-gray-800 mb-2 cursor-pointer select-none" id="pageTitle" ondblclick="toggleDeveloperMode()" title="雙擊切換開發者模式">📅 待辦事項日曆</h1>
                        <p class="text-gray-600">管理您的每日待辦事項<span id="devModeIndicator" class="hidden text-red-500 font-bold ml-2">[開發者模式]</span></p>
                    </div>
                    <!-- 使用者選擇區域 -->
                    <div class="w-full lg:w-auto">
                        <div class="bg-white rounded-lg shadow-md p-3">
                            <div class="flex flex-col gap-2 sm:flex-row sm:flex-wrap sm:items-center">
                                <div class="flex items-center gap-2 w-full sm:w-auto">
                                    <span class="text-sm text-gray-600 shrink-0">使用者：</span>
                                    <input type="text" id="currentUserNameInput" value=""
                                           class="w-full sm:w-auto px-3 py-2 sm:py-1 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 font-semibold text-gray-800 min-w-0 sm:min-w-[180px]"
                                           placeholder="輸入使用者名稱">
                                </div>
                                <div class="grid grid-cols-2 sm:flex sm:flex-wrap gap-2 w-full sm:w-auto">
                                    <button onclick="saveCurrentUserName()"
                                            class="px-3 py-2 sm:py-1 bg-green-600 text-white rounded-lg hover:bg-green-700 transition text-sm font-semibold"
                                            title="保存使用者名稱">
                                        💾 保存
                                    </button>
                                    <button onclick="exportUserData()"
                                            class="px-3 py-2 sm:py-1 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition text-sm font-semibold"
                                            title="匯出日曆資料">
                                        📥 匯出資料
                                    </button>
                                    <button id="resetButton" onclick="openResetModal()"
                                            class="px-3 py-2 sm:py-1 bg-red-600 text-white rounded-lg hover:bg-red-700 transition text-sm font-semibold hidden col-span-2 sm:col-auto"
                                            title="重置所有數據（開發者模式）">
                                        🔄 重置
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
            </div>
        </header>

            <!-- 版面反轉：手機左右並排（可滑動），桌機一頁式（上下） -->
            <div class="-mx-4 md:mx-0 overflow-x-auto lg:overflow-visible">
                <div class="flex flex-row lg:flex-col gap-6 min-w-[860px] lg:min-w-0 px-4 md:px-0">
                <!-- 左側：月曆 -->
                <div class="w-[560px] lg:w-full shrink-0">
                    <div class="bg-white rounded-xl shadow-lg p-3 sm:p-6">
                        <!-- 月曆控制 -->
                        <div class="flex justify-between items-center mb-4 sm:mb-6">
                            <button onclick="changeMonth(-1)" class="p-2 rounded-lg hover:bg-gray-100 transition">
                                <svg class="w-6 h-6 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                                </svg>
                            </button>
                            <h2 class="text-2xl font-bold text-gray-800" id="currentMonthYear"></h2>
                            <button onclick="changeMonth(1)" class="p-2 rounded-lg hover:bg-gray-100 transition">
                                <svg class="w-6 h-6 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                                </svg>
                            </button>
                    </div>

                        <!-- 星期標題 -->
                        <div class="grid grid-cols-7 gap-1 sm:gap-2 mb-2 text-xs sm:text-sm">
                            <div class="text-center font-semibold text-gray-600 py-1 sm:py-2">日</div>
                            <div class="text-center font-semibold text-gray-600 py-1 sm:py-2">一</div>
                            <div class="text-center font-semibold text-gray-600 py-1 sm:py-2">二</div>
                            <div class="text-center font-semibold text-gray-600 py-1 sm:py-2">三</div>
                            <div class="text-center font-semibold text-gray-600 py-1 sm:py-2">四</div>
                            <div class="text-center font-semibold text-gray-600 py-1 sm:py-2">五</div>
                            <div class="text-center font-semibold text-gray-600 py-1 sm:py-2">六</div>
                    </div>

                        <!-- 月曆網格 -->
                        <div id="calendarGrid" class="grid grid-cols-7 gap-1 sm:gap-2">
                            <!-- 月曆內容將由 JavaScript 生成 -->
                        </div>
                    </div>
                </div>

                <!-- 右側：選中日期的待辦事項 -->
                <div class="w-[280px] lg:w-full shrink-0 space-y-6">
                    <!-- 選中日期的待辦事項區塊（整合語錄顯示） -->
                    <div class="bg-white rounded-xl shadow-lg p-3 sm:p-6">
                        <div class="mb-4">
                            <div class="mb-1">
                                <h3 class="text-xl font-bold text-gray-800" id="selectedDateTitle">
                                選擇日期
                            </h3>
                            </div>
                            <p class="text-xs text-gray-500" id="currentUserDisplay">當前使用者：<span id="currentUserName"></span></p>
            </div>

                        <!-- 每日語錄顯示區域（整合在此） -->
                        <div id="dailyQuoteCard" class="mb-4">
                            <!-- 每日語錄內容將由 JavaScript 生成 -->
                        </div>

                        <!-- 待辦事項列表 -->
                        <div id="todoList" class="space-y-2 mb-4 min-h-[200px]">
                            <p class="text-gray-400 text-sm text-center py-8">請選擇日期查看待辦事項</p>
                </div>

                        <!-- 新增待辦事項表單 -->
                        <div id="addTodoForm" class="hidden">
                            <div class="border-t pt-4 mt-4">
                                <h4 class="font-semibold text-gray-700 mb-3">新增待辦事項</h4>
                                <input type="text"
                                       id="newTodoInput"
                                       placeholder="輸入待辦事項..."
                                       class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 mb-2">
                                <button onclick="addTodo()"
                                        class="w-full py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition font-semibold">
                                    ➕ 新增
                                </button>
                    </div>
                </div>
            </div>

                    <!-- 所有待辦事項日期列表區塊（獨立區塊） -->
                    <div class="bg-white rounded-xl shadow-lg p-3 sm:p-6">
                        <h4 class="font-semibold text-gray-700 mb-4 flex items-center text-lg">
                            <span class="mr-2">📋</span> 所有待辦事項
                        </h4>
                        <div id="allTodosContent" class="space-y-2 max-h-[400px] overflow-y-auto">
                            <!-- 待辦事項日期列表將由 JavaScript 生成 -->
                    </div>
                    </div>
                    </div>
                    </div>
                </div>
            </div>
                </div>
            </div>

    <!-- API Key 設置 Modal -->
    <div id="apiKeyModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-md p-6">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">🔑 設置 Gemini API Key</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Gemini API Key</label>
                    <input type="password" id="geminiApiKeyInput" placeholder="輸入您的 Gemini API Key..."
                           class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    <p class="text-xs text-gray-500 mt-2">用於生成語錄卡片圖片（可選）</p>
                </div>
                <div class="flex gap-3">
                    <button onclick="saveApiKey()"
                            class="flex-1 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition font-semibold">
                        保存
                    </button>
                    <button onclick="closeApiKeyModal()"
                            class="flex-1 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition font-semibold">
                        取消
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- 解鎖日期 Modal -->
    <div id="unlockDateModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-md p-6">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">🔓 解鎖日期</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">請輸入日期（格式：MMDD）</label>
                    <input type="text" id="unlockDateInput" placeholder="輸入日期"
                           maxlength="4"
                           class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-center text-2xl font-bold tracking-widest">
                </div>
                <div class="flex gap-3">
                    <button onclick="confirmUnlockDate()"
                            class="flex-1 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition font-semibold">
                        解鎖
                    </button>
                    <button onclick="closeUnlockModal()"
                            class="flex-1 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition font-semibold">
                        取消
                    </button>
                </div>
                <p id="unlockErrorMsg" class="text-red-500 text-sm text-center hidden"></p>
            </div>
        </div>
    </div>

    <!-- 新增使用者 Modal -->
    <div id="addUserModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-md p-6">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">新增使用者</h3>
                <div class="space-y-4">
                        <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">使用者名稱</label>
                    <input type="text" id="newUserNameInput" placeholder="輸入使用者名稱"
                           class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                <div class="flex gap-3">
                    <button onclick="addNewUser()"
                            class="flex-1 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition font-semibold">
                        新增
                    </button>
                    <button onclick="closeAddUserModal()"
                            class="flex-1 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition font-semibold">
                        取消
                    </button>
                        </div>
                    </div>
                </div>
    </div>

    <!-- 重置確認 Modal -->
    <div id="resetModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-md p-6">
            <h3 class="text-2xl font-bold text-red-600 mb-4">⚠️ 重置所有數據</h3>
            <div class="space-y-4">
                <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                    <p class="text-sm text-red-800 font-semibold mb-2">此操作將清除：</p>
                    <ul class="text-sm text-red-700 space-y-1 list-disc list-inside">
                        <li>所有使用者的待辦事項</li>
                        <li>所有使用者的解鎖記錄</li>
                        <li>所有使用者的每日語錄</li>
                        <li>所有自訂使用者（保留默認使用者）</li>
                    </ul>
                    <p class="text-sm text-red-800 font-semibold mt-3">⚠️ 此操作無法復原！</p>
                </div>
                <div class="flex gap-3">
                    <button onclick="confirmReset()"
                            class="flex-1 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition font-semibold">
                        確認重置
                    </button>
                    <button onclick="closeResetModal()"
                            class="flex-1 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition font-semibold">
                        取消
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 狀態管理
        let currentDate = new Date();
        let selectedDate = null;
        let currentUserId = localStorage.getItem('currentUserId') || 'default';
        let users = JSON.parse(localStorage.getItem('users') || '["default"]');
        let todos = {};

        // 開發者模式
        let developerMode = localStorage.getItem('developerMode') === 'true';

        // 使用者管理
        function initUsers() {
            // 如果沒有使用者，創建預設使用者
            if (users.length === 0) {
                users = ['default'];
                saveUsers();
            }

            // 如果當前使用者不存在，使用第一個使用者
            if (!users.includes(currentUserId)) {
                currentUserId = users[0];
                saveCurrentUser();
            }

            // 載入當前使用者的待辦事項
            loadUserTodos();

            // 更新使用者名稱輸入框
            updateCurrentUserNameInput();
        }

        function updateCurrentUserNameInput() {
            const userNameInput = document.getElementById('currentUserNameInput');
            if (userNameInput) {
                userNameInput.value = currentUserId;
            }
        }

        // 保存當前使用者名稱（如果名稱改變，會創建新的使用者）
        function saveCurrentUserName() {
            const userNameInput = document.getElementById('currentUserNameInput');
            const newUserName = userNameInput.value.trim();

            if (!newUserName) {
                alert('使用者名稱不能為空');
                return;
            }

            if (newUserName === currentUserId) {
                alert('使用者名稱沒有改變');
                return;
            }

            // 保存當前使用者的資料
                saveUserTodos();

            // 檢查是否已有這個使用者
            if (!users.includes(newUserName)) {
                // 創建新使用者
                users.push(newUserName);
                saveUsers();
            }

            // 切換到新使用者
            currentUserId = newUserName;
                saveCurrentUser();

                // 載入新使用者的資料
                loadUserTodos();

                // 清除選中狀態
                selectedDate = null;
                document.getElementById('selectedDateTitle').textContent = '選擇日期';
                document.getElementById('todoList').innerHTML = '<p class="text-gray-400 text-sm text-center py-8">請選擇日期查看待辦事項</p>';
                document.getElementById('addTodoForm').classList.add('hidden');

                // 重新渲染
                renderCalendar();
            renderAllTodosList();
            renderDailyQuote();
            // 同步所有已解鎖的語錄到待辦事項
            syncAllQuotesToTodos().then(() => {
                renderCalendar();
                renderAllTodosList();
            });

            alert('使用者名稱已保存！');
        }

        // 匯出當前使用者的日曆資料
        function exportUserData() {
            const userData = {
                userId: currentUserId,
                exportDate: new Date().toISOString(),
                todos: todos,
                dailyQuotes: loadDailyQuotes(),
                unlockedDates: loadUnlockedDates(),
                usedQuotes: getUsedQuotes(),
                usedThemes: getUsedThemes()
            };

            const json = JSON.stringify(userData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentUserId}_日曆資料_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            alert(`✅ ${currentUserId} 的日曆資料已匯出！`);
        }

        function loadUserTodos() {
            const todosKey = `todos_${currentUserId}`;
            todos = JSON.parse(localStorage.getItem(todosKey) || '{}');
            renderAllTodosList(); // 載入使用者資料後更新列表
        }

        function saveUserTodos() {
            const todosKey = `todos_${currentUserId}`;
            localStorage.setItem(todosKey, JSON.stringify(todos));
        }

        function saveUsers() {
            localStorage.setItem('users', JSON.stringify(users));
        }

        function saveCurrentUser() {
            localStorage.setItem('currentUserId', currentUserId);
        }

        // switchUser 函數已移除，改用 saveCurrentUserName

        function openAddUserModal() {
            document.getElementById('addUserModal').classList.remove('hidden');
            document.getElementById('newUserNameInput').value = '';
            document.getElementById('newUserNameInput').focus();
        }

        function closeAddUserModal() {
            document.getElementById('addUserModal').classList.add('hidden');
        }

        function addNewUser() {
            const input = document.getElementById('newUserNameInput');
            const userName = input.value.trim();

            if (!userName) {
                alert('請輸入使用者名稱');
                return;
            }

            if (users.includes(userName)) {
                alert('此使用者名稱已存在');
                return;
            }

            // 新增使用者
            users.push(userName);
            saveUsers();

            // 切換到新使用者
            currentUserId = userName;
            saveCurrentUser();
            todos = {};
            saveUserTodos();

            // 更新 UI
            updateCurrentUserNameInput();
            renderCalendar();
            renderAllTodosList(); // 更新所有待辦事項列表
            renderDailyQuote().catch(err => console.error('渲染語錄失敗:', err)); // 更新每日語錄
            closeAddUserModal();

            // 清除選中狀態
            selectedDate = null;
            document.getElementById('selectedDateTitle').textContent = '選擇日期';
            document.getElementById('todoList').innerHTML = '<p class="text-gray-400 text-sm text-center py-8">請選擇日期查看待辦事項</p>';
            document.getElementById('addTodoForm').classList.add('hidden');
        }

        // 重置功能
        function openResetModal() {
            document.getElementById('resetModal').classList.remove('hidden');
        }

        function closeResetModal() {
            document.getElementById('resetModal').classList.add('hidden');
        }

        function confirmReset() {
            // 清除所有使用者的待辦事項
            const allKeys = Object.keys(localStorage);
            allKeys.forEach(key => {
                if (key.startsWith('todos_')) {
                    localStorage.removeItem(key);
                }
                if (key.startsWith('unlockedDates_')) {
                    localStorage.removeItem(key);
                }
                if (key.startsWith('dailyQuotes_')) {
                    localStorage.removeItem(key);
                }
                if (key === 'dailyQuotes_list') {
                    localStorage.removeItem(key);
                }
                if (key.startsWith('usedQuotes_')) {
                    localStorage.removeItem(key);
                }
                if (key.startsWith('usedThemes_')) {
                    localStorage.removeItem(key);
                }
            });

            // 重置使用者列表（保留默認使用者）
            users = ['default'];
            saveUsers();

            // 重置當前使用者
            currentUserId = 'default';
            saveCurrentUser();

            // 重置待辦事項
            todos = {};
            saveUserTodos();

            // 重置選中日期
            selectedDate = null;

            // 關閉 Modal
            closeResetModal();

            // 重新初始化並渲染
            initUsers();
            renderCalendar();
            renderTodos();
            renderAllTodosList();
            renderDailyQuote().catch(err => console.error('渲染語錄失敗:', err));

            alert('✅ 所有數據已重置！');
        }

        // 支援 Enter 鍵新增使用者
        document.getElementById('newUserNameInput')?.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addNewUser();
            }
        });

        // 月份名稱
        const monthNames = ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'];
        const dayNames = ['日', '一', '二', '三', '四', '五', '六'];

        // 每日語錄數據庫
        // 從 quotes-data.html 載入語錄列表
        let dailyQuotesLoaded = false;
        let dailyQuotesData = [];

        // 從 quotes-data.html 載入語錄
        function loadQuotesFromFile() {
            return new Promise((resolve, reject) => {
                if (dailyQuotesLoaded) {
                    resolve(dailyQuotesData);
                    return;
                }

                // 使用 iframe 載入 quotes-data.html
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                iframe.src = 'quotes-data.html';

                iframe.onload = function() {
                    try {
                        const quotesWindow = iframe.contentWindow;
                        if (quotesWindow && quotesWindow.DAILY_QUOTES_LIST) {
                            dailyQuotesData = quotesWindow.DAILY_QUOTES_LIST;
                            dailyQuotesLoaded = true;
                            document.body.removeChild(iframe);
                            resolve(dailyQuotesData);
                        } else {
                            // 如果載入失敗，使用默認語錄
                            dailyQuotesData = getDefaultQuotes();
                            dailyQuotesLoaded = true;
                            document.body.removeChild(iframe);
                            resolve(dailyQuotesData);
                        }
                    } catch (e) {
                        console.error('載入語錄失敗:', e);
                        // 使用默認語錄
                        dailyQuotesData = getDefaultQuotes();
                        dailyQuotesLoaded = true;
                        document.body.removeChild(iframe);
                        resolve(dailyQuotesData);
                    }
                };

                iframe.onerror = function() {
                    console.error('無法載入 quotes-data.html');
                    dailyQuotesData = getDefaultQuotes();
                    dailyQuotesLoaded = true;
                    if (iframe.parentNode) {
                        document.body.removeChild(iframe);
                    }
                    resolve(dailyQuotesData);
                };

                document.body.appendChild(iframe);

                // 設置超時，如果 3 秒內沒載入完成就使用默認值
                setTimeout(() => {
                    if (!dailyQuotesLoaded) {
                        dailyQuotesData = getDefaultQuotes();
                        dailyQuotesLoaded = true;
                        if (iframe.parentNode) {
                            document.body.removeChild(iframe);
                        }
                        resolve(dailyQuotesData);
                    }
                }, 3000);
            });
        }

        // 獲取默認語錄（作為備用）
        function getDefaultQuotes() {
            return [
            "不期待 不假設 不強求\n是保持情緒穩定的秘訣",
            "沒人能打擾你內心的平靜\n除非你拱手相讓",
            "別希望別盼望\n別指望 就不會失望",
            "勇敢就是\n把做自己當成日常",
            "這一路很難\n但還是撐過來了",
            "如果不是這個\n就一定有更好的",
            "不要因為現實生活的煩躁\n而放棄感覺的能力",
            "學會自愛\n就不怕被打敗",
            "絕對不要在糟糕的那天\n揚言放棄",
            "首先你要開心\n其次都是其次",
            "I am because you are\n我存在 是因為你",
            "Let it be\nTo be or not to be",
            "如果方向錯了\n停止就是最大的進步",
            "你拼命逗笑的人\n終究比不過",
            "出生不該被嘲笑\n夢想不該被羞恥",
            "夢想不會逃走 \n逃走的一直都是自己",
            "情況不會變得更好\n但也變得更不一樣了",
            "只要活得夠久 生命的長度\n就會稀釋錯誤的濃度",
            "人生有兩種事 一種是好事\n另一種是不知道好在哪的事",
            "竹籃打水一場空\n至少竹籃乾淨了",
            "先開口 被拒絕了再說\n記得先做個垃圾出來",
            "不要害怕三分鐘熱度\n至少會有三分鐘收穫",
            "恨是生產力\n愛 只能生產",
            "成長不是讓所有人喜歡你\n而是學會接受有人不喜歡你",
            "有些人能夠共存已經很好\n硬要相處就是奢求",
            "懂事聽起來是稱讚\n但其實是要我們受委屈",
            "憂鬱的根本\n是失去自我",
            "心太累的時候\n先原諒自己",
            "盡情生活\n做過的事情都不要後悔",
            "睡前原諒一切\n醒來便是重生",
            "GoogleMap不會責備你\n所以你也別責備你自己",
            "不必急著讓努力立刻見效\n也不必事事都做到完美",
            "不需要爭強好勝\n只要活出精彩",
            "沒有憂愁的時候\n就是最好的時候",
            "把痛苦放回他該去的位置\n人生有很多值得期待的事",
            "沒有人一直在看你\n活著不需要有任何包袱",
            "照顧好自己\n就是成家了",
            "三思而後行\n再，斯可矣",
            "要嘛大爆炸\n要嘛一起死",
            "凡事先去做\n過程在縫縫補補",
            "周圍吵雜的聲音\n真的沒有那麼重要",
            "不要因為別人的看法\n影響自己的情緒",
            "每一天每一個層面\n我都越來越好",
            "在好起來之前\n先接受自己無能為力",
            "別指望任何人\n請好好愛自己",
            "公平的是\n我們的失去都是對等的",
            "什麼都無所謂\n才是支離破碎",
            "不會因為你善良就對你溫柔\n記得對自己溫柔一點",
            "拎著一袋垃圾 \n就會錯過很多的禮物",
            "沒有什麼放不下\n想得太多只會讓人生更累",
            "安慰並鼓勵所有人\n唯獨不肯放過自己",
            "學會溫柔以待\n接納不完美的自己",
            "清者自清\n不需要向任何人解釋",
            "我經歷黑暗\n但我保持清澈初心",
            "誰都可以不喜歡你\n但你自己不可以",
            "人總要嚥下些委屈\n接著隻字不提的向前走",
            "若無法改變現狀\n那就享受當下",
            "這只是糟糕的一天\n沒什麼大不了",
            "人生除了生死\n其他都是小事",
            "我們都不用改\n不舒服的關係就斷開",
            "天黑可以矯情\n天亮就得拼命",
            "成年人的最大成就\n是克制糾正他人的慾望",
            "你比你自己想像的還要勇敢\n別因他人的話而讓自己黯淡",
            "這個世界不缺少成功的人\n我們需要更多的講故事",
            "長大吧！\n這個世界不是你的老母親。",
            "悲觀通常不意味著生活艱難和疲憊\n而是無法控制的想像。",
            "當命運要求你逆風飛翔時\n希望你不要選擇隨波逐流。",
            "能從暴風雨中走出來的人\n從來不是因為有把傘。",
            "我們沒有做錯什麼\n但我們輸了。",
            "只有經過深刻的教訓\n才能明白這句話的意義。",
            "珍惜你低潮的時候\n你會看到很多真相。",
            "照亮生命的不是美景\n而是一個好的希望。",
            "無論如何，歲月漫長\n但值得等待。",
            "禁錮自己\n是一個標籤，一個偏見。",
            "心氣是不可再生之物\n珍惜",
            "讓生命如夏花般絢麗\n死亡如秋葉般靜美。",
            "在變好之前\n事情總會變得更糟。",
            "它總是會發光的\n即使沒有太陽。",
            "讓自己變得更好\n讓自己快樂。",
            "不要為不重要的人和事操心\n長期心結。",
            "死亡\n只是另一場偉大的冒險。",
            "人生無非就是兩種結果\n可笑且有效。",
            "人生就是這樣\n無論怎麼走，總會有遺憾。",
            "當下坡足夠快的時候\n展開翅膀，克服困難。",
            "及時醒悟\n也願意付出一切。",
            "沒有人會永遠愛你\n但總會有人愛你。",
            "風停在窗邊\n告訴你要愛這個世界。",
            "別人的看法僅僅是看法\n沒有人比你自己更懂得做自己。",
            "在人生中\n沒有一定要實現的目標。",
            "每一個雨天之後都是晴天\n風暴過後會有彩虹。",
            "勇敢面對\n迎接下一個挑戰。",
            "跌倒了沒關係\n再站起來就好，或者就躺著吧。",
            "如果你不知道如何休息\n怎麼知道如何前進。",
            "放過這條小溪吧\n還有更美的山川。",
            "如果人生是一列火車\n車票就是經歷。",
            "不要因為別人\n而影響自己的心情。",
            "幸福是一種修行\n但它不是人生的唯一。",
            "真正的幸福\n是努力爬上山巔。",
            "我是天空\n容納任何一朵雲。",
            "生活繼續\n超越心情之外。",
            "告別那些心痛\n剩下的人生每一刻都值得激動。",
            "人生沒有標準答案\n珍惜當下就是最好的答案。",
            "經歷風雨\n才能在動盪中保持平靜。",
            "累了，說明又在上坡路上了。\n難了，說明我們在進步。",
            "在沒有人在意的地方\n在聚光燈下出現。",
            "玩得開心\n卻也悲傷。",
            "長大\n是人必須經歷的一場腐爛。",
            "忘記是一個部分的複數詞\n我騙自己忘了，但其實還記得。",
            "不知道我要去哪裡\n但我已經在路上了。",
            "即使大家都不放在心上\n我還是我。",
            "雲想衣裳花想容\n春風拂檻露華濃。",
            "你在意什麼\n什麼就會折磨你。",
            "沒有人不在努力\n只是沒喊出痛苦。",
            "有好的心態\n才能有好的狀態。",
            "一切都會結束\n我的煩惱無盡。",
            "最黑暗的時刻\n總會有一絲光亮。",
            "擺脫不必要的內疚\n不要委屈自己去討好別人。",
            "接受自己每個階段的樣子\n努力與自己和解。",
            "努力成為值得被愛的人\n而不是強迫別人愛上自己糟糕的一面。",
            "許多事情都是個人選擇\n你必須喜歡那個做出選擇的自己。",
            "知道你不完美\n接受你不完美。",
            "找不到要走的路\n那就先走眼前的路吧。",
            "你並不缺乏正能量\n只怕自己不夠強大。",
            "走得慢沒關係\n只要你不停下來。",
            "不要讓當前的遺憾\n成為未來生活的嘆息。",
            "我是隻烏龜\n我不想打敗兔子，我只想喜歡我自己。",
            "被忽視的感覺\n真的很難受。",
            "沒有人會無緣無故消失\n只有不想聯繫的人。",
            "當生活都是上坡路的時候\n那才會這麼吃力。",
            "即使走得蹣跚\n也要努力前行。",
            "做自己\n也可以活得很精彩。",
            "好好活著，好好告別\n那就是幸福。",
            "如果明天還在\n今天我們能不能重新開始？",
            "當你做自己的時候\n真的不應該期待被喜歡。",
            "不是真的想死\n只是不知道如何活下去。",
            "做自己\n因為別人已經被做過了。",
            "多一分\n就是多一分。",
            "不要踮起腳尖去愛\n這只會讓狗吃屎。",
            "與你無關的事\n卻是別人一生的痛苦。",
            "當你選擇這條路\n另一條路上的風景就與你無關了。",
            "所謂低調\n就是不露痕跡的高調。",
            "接受自己平凡的樣子\n然後盡力做到不一樣。",
            "幸福不是羨慕別人\n而是活得像自己。",
            "放手吧\n不要再執著了。",
            "不要害怕前方的黑暗\n你正在散發光芒。",
            "正義或許會遲到\n但永不缺席。",
            "雖然今天的努力很艱辛，\n但那些都是來自未來的禮物。",
            "你只會年輕一次\n去享受你的青春吧。",
            "生命就是不斷遇見\n又不斷分別的過程",
            "時間比眼睛\n更能看清一些東西",
            "醒來\n方知是夢",
            "路上總有陰影\n但抬頭總能見光",
            "有心者有所累\n無心者無所謂",
            "不要騙自己努力過了\n就會長出翅膀",
            "自我感動的付出 \n既危險又愚蠢",
            "盛不盛開 \n花都是花",
            "既然去不了遠方\n就感受沿路的風景",
            "去吹吹風吧\n能清醒，感冒也沒關係",
            "人生是用來體驗的\n不是用來演繹完美的",
            "加油不要放棄 \n現在害怕是因為沒有做好",
            "別對自己失望\n你只是太想把事情做好",
            "累了就慢慢走\n偶爾停下來沒關係",
            "都要高處相見\n海裡的美怎麼參觀",
            "希望你別有壓力\n人生不是競技",
            "沒有事事如意\n只能順其心意",
            "大多沒有正確答案\n只有適合自己的解答",
            "給自己一對翅膀\n強迫自己學會飛翔",
            "我是大海\n與波濤共存",
            "好好記得 \n自己努力時的樣子",
            "不打開的開門\n再敲就不禮貌了",
            "已歡喜之心\n度平日之日",
            "先努力優秀\n再大方擁有",
            "時間來不及細算\n過往來不及想看",
            "不用很厲害才開始\n要先開始才會很厲害",
            "殺不死你的\n終會使你強大",
            "遺憾的反面不是完美\n而是懂得放下",
            "這個世界不美好\n但總有人守護著你",
            "偏見\n是無法僭越的高牆",
            "生活需要煙火\n也需要靜靜的美好",
            "這個世界本來就不好\n但，你要記得，你很好",
            "有些煩惱，丟掉了\n才有雲淡風輕的機會",
            "如果沒有躺贏的命\n那就站起來奔跑吧",
            "每天都在學習放手\n活在當下就別害怕失去",
            "萬般皆是命\n半點不由人",
            "風雨人生\n給自己一個微笑",
            "即便很堅強\n也不代表不會受傷",
            "播種美好希望\n收穫幸福時光",
            "沒有期待的日子\n反而順順利利",
            "學會發現自己的好\n別把重要的自己當作隱形人",
            "大部分的人不會感謝你的善良\n除了得寸進尺還是得寸進尺",
            "活成一座孤島\n也要有屬於自己的美好",
            "沒必要體諒所有人\n有些人也不會體諒你",
            "人生沒有白走的路\n每一步都算數",
            "沒有過不去的坎\n只有轉不過的念",
            "如果兔子都拼命奔跑 \n烏龜該怎麼辦？",
            "不能與之為敵\n便與之為伍",
            "有時後也想問\n是不是這樣就好",
            "沒什麼好後悔的\n即使可以再來一次",
            "你停下腳步的時候\n世界並不會停下來等你",
            "現在的堅持\n是為了讓未來有更多選擇",
            "不用太認真的活著\n對得起自己就好",
            "寧可讓人討厭真實的你\n也好過讓別人愛上虛偽的自己",
            "握在手裡的風箏\n也會突然斷了線",
            "你所經歷的一切\n都會過去",
            "照顧好自己\n才是最負責任的生活方式",
            "學會自嘲\n我們都不完美",
            "起得晚\n就要更努力",
            "別在機場等船\n只會等到得寸進尺",
            "寧肯天真的哭\n也不願無恥的笑",
            "既然放不下\n就先擱著吧",
            "思念的聲音很輕\n但我們都聽得到",
            "雖然人生充滿遺憾\n但也因此更美好",
            "人生難題一再出現\n都是為了考驗你有沒有改變",
            "不願意種花\n是不願意看到他凋零",
            "喜是初見歡\n愛是久不厭",
            "想改變\n什麼時候都不晚",
            "不要覺得路途遙遠\n回頭都是你堅持的足跡",
            "早餐店沒有賣晚上的\n想買的人，早上就來了",
            "放平心態 偷偷厲害\n萬事盡可期待",
            "有一種聰明 叫做傻\n有一種傻 叫自作聰明",
            "最好的貴人\n就是努力的自己",
            "巧克力變巧克力之前\n都是苦的",
            "沒有熱忱\n世間便無進步",
            "沒有人能獨自堅強\n我們都要幫助所愛的人",
            "你成為什麼\n就會吸引什麼",
            "當你找到自己\n全世界都會來愛你",
            "只要你願意努力\n最壞的結果也只是大器晚成",
            "如果你想攀登高峰\n別把彩虹當作階梯，會摔死",
            "把簡單弄複雜是找麻煩\n把複雜弄簡單才是本事",
            "獨立的過程很辛苦  但走過這段路\n獲得的東西也一定比別人多",
            "人生路上死不了人的，\n都是擦傷。",
            "開始迷茫的時候不要逃避\n那是解決麻煩的開始",
            "沒必要去做第一\n但必須去做唯一",
            "讓朋友低估你的優點\n讓敵人高估你的缺點",
            "我望著自己伸出的手\n疑惑能成為誰的救贖",
            "練習自己的快樂\n不要跟別人比較",
            "如果沒見過太陽\n我本可以忍受黑暗",
            "哭不是堅強\n忍住不哭才是成長",
            "做對的事情\n比把事情做對更重要",
            "屬於你的就珍惜\n不是你的就別要",
            "一個不了解自己的人\n很難得到自己想要的東西",
            "煽動的話語必定好聽\n誣衊的語言必能成長",
            "成為自己喜歡的樣子吧！\n不要放棄過往的努力。",
            "訂個目標\n告訴自己能行的",
            "未盡全力，\n除了自己又能怪誰？",
            "所有看似美好的\n都經歷過或者正在經歷著不美好。",
            "不是所有碎片都能拼湊\n就像那些昨天無法重新擁有",
            "想念離我如此之近\n才發現你多遙不可及",
            "你要給在 身邊的人機會\n他們才會告訴你，你值得",
            "溫婉的憐憫來敲門\n再厚的鐵門也總會打開",
            "現實中壞人不會是巫婆樣\n好人也不會寫在臉上",
            "你不用對這個世界太沮喪\n因為你一定也曾經傷害過一些人",
            "贏不一定有道理\n輸肯定有原因",
            "哪有什麼輕易得到的幸運\n幸運只是結果而已",
            "你相信什麼\n就會朝向什麼",
            "為了融入社會不得不偽裝自己\n問自己，有必要嗎？",
            "可，因為信念\n不可，因為信仰",
            "不要憎恨敵人\n那會影響你的判斷能力",
            "恐懼，是看見你不相信的\n信念，是相信你看不見的",
            "生活也許很苦\n但他並不會放棄你",
            "不要守着那份委屈\n屬於你的光芒終會為你綻放",
            "I like you\nbut just like you",
            "過不了高牆\n看不到遠方",
            "自己不堅強\n弱給誰看",
            "精力好的人\n會集中能量做重要的事",
            "逆水行舟\n不進則退",
            "你不需要很厲害才能開始\n你需要開始才能很厲害",
            "只有開始，\n才有故事。",
            "唯有做思想的旁觀者\n才能看清自己。",
            "為強者  積于弱\n有余者 積于不足",
            "迷路的時候放下自尊與面子\n是自我成長的第一步",
            "世界是你自己的\n與他人毫無關係",
            "回頭看自己走過的路才開始後悔\n後悔沒能活成自己想要的樣子",
            "不能改變未來，就改變當下\n唯有改變，未來的路才能越漸不同",
            "每個人都希望善惡有報\n但沒人想要弄髒自己的手，人間。",
            "你必須找到你所愛的東西\n不僅是工作、戀愛，亦是生活",
            "處無為之事\n行不言之教",
            "對自己好一點\n那是會跟你最久的人",
            "這人間真的不值得\n但你  超值得。",
            "知道和做到是兩碼事\n別總是敷衍著回答來掩藏自己的無能",
            "你現在焦慮的事情\n後來一件都沒有發生，告訴未來的我",
            "世界之大 何吾處\n世界不小 何苦吾",
            "日子苦了\n連黑咖啡有點是甜的",
            "英雄路過時總會有人拍手\n我只想當那個拍手的人，不想當英雄",
            "你的生活，需要點儀式感\n可以很講究也可以很隨便。",
            "要懂得知而不言\n因為言多必失",
            "盡情生活\n做過的每件事情都別後悔",
            "如果你沒有完美的人生\n那就自己創造吧",
            "做好當前點滴 學會學習\n相信人間真善美",
            "人生總會遇到許多問題\n如果只會抱怨，那還真是廢物。",
            "生活是面鏡子\n你對他笑，他便笑。 你哭，他哭。",
            "再怎麼不開心，秒針還是再走\n人生要跟時間賽跑，別鬧脾氣。"
        ];
        }

        // 保存語錄列表到 localStorage
        function saveDailyQuotesList(quotes) {
            localStorage.setItem('dailyQuotes_list', JSON.stringify(quotes));
        }

        // 獲取語錄列表（從 quotes-data.html 載入）
        async function getDailyQuotes() {
            if (!dailyQuotesLoaded) {
                await loadQuotesFromFile();
            }
            return dailyQuotesData;
        }

        // 用於兼容的變數（會在載入後更新）
        let dailyQuotes = [];

        // 解鎖狀態管理
        let unlockModalDateKey = null;
        let unlockModalDate = null;
        let geminiApiKey = localStorage.getItem('geminiApiKey') || '';

        // 載入解鎖記錄
        function loadUnlockedDates() {
            const key = `unlockedDates_${currentUserId}`;
            return JSON.parse(localStorage.getItem(key) || '[]');
        }

        // 保存解鎖記錄
        function saveUnlockedDates(dates) {
            const key = `unlockedDates_${currentUserId}`;
            localStorage.setItem(key, JSON.stringify(dates));
        }

        // 切換開發者模式
        function toggleDeveloperMode() {
            developerMode = !developerMode;
            localStorage.setItem('developerMode', developerMode.toString());
            updateDeveloperModeIndicator();
            // 同步更新最上方「工具集」導覽列（僅開發者模式顯示）
            if (typeof window.__evedayRefreshNav === 'function') {
                window.__evedayRefreshNav();
            }
            // 更新重置按鈕顯示狀態
            updateResetButtonVisibility();
            // 重新渲染月曆以顯示/隱藏快速打卡按鈕
            renderCalendar();
            renderDailyQuote().catch(err => console.error('渲染語錄失敗:', err)); // 重新渲染語錄顯示
            alert(developerMode ? '✅ 開發者模式已開啟！\n現在可以直接打卡任何日期。\n點擊月曆上日期右上角的✓按鈕即可快速打卡。' : '✅ 開發者模式已關閉。');
        }

        // 更新開發者模式指示器
        function updateDeveloperModeIndicator() {
            const indicator = document.getElementById('devModeIndicator');
            if (indicator) {
                if (developerMode) {
                    indicator.classList.remove('hidden');
                } else {
                    indicator.classList.add('hidden');
                }
            }
        }

        // 更新重置按鈕的顯示狀態
        function updateResetButtonVisibility() {
            const resetBtn = document.getElementById('resetButton');
            if (resetBtn) {
                if (developerMode) {
                    resetBtn.classList.remove('hidden');
                } else {
                    resetBtn.classList.add('hidden');
                }
            }
        }

        // 檢查日期是否已解鎖（開發者模式下總是返回 true）
        function checkDateUnlocked(dateKey) {
            if (developerMode) return true; // 開發者模式下總是已解鎖
            const unlockedDates = loadUnlockedDates();
            return unlockedDates.includes(dateKey);
        }

        // 解鎖日期
        function unlockDate(dateKey) {
            const unlockedDates = loadUnlockedDates();
            if (!unlockedDates.includes(dateKey)) {
                unlockedDates.push(dateKey);
                saveUnlockedDates(unlockedDates);
            }
        }

        // 打開解鎖彈窗
        function openUnlockModal(dateKey, date) {
            unlockModalDateKey = dateKey;
            unlockModalDate = date;
            document.getElementById('unlockDateModal').classList.remove('hidden');
            document.getElementById('unlockDateInput').value = '';
            document.getElementById('unlockDateInput').focus();
            document.getElementById('unlockErrorMsg').classList.add('hidden');
        }

        // 關閉解鎖彈窗
        function closeUnlockModal() {
            document.getElementById('unlockDateModal').classList.add('hidden');
            unlockModalDateKey = null;
            unlockModalDate = null;
        }

        // 確認解鎖日期
        function confirmUnlockDate() {
            const input = document.getElementById('unlockDateInput');
            const inputValue = input.value.trim();
            const errorMsg = document.getElementById('unlockErrorMsg');

            // 開發者模式下可以解鎖任何日期，否則只能解鎖當天
            if (!developerMode) {
            const todayKey = getTodayKey();
            if (unlockModalDateKey !== todayKey) {
                errorMsg.textContent = '只能解鎖當天的日期！';
                errorMsg.classList.remove('hidden');
                return;
                }
            }

            if (!inputValue || inputValue.length !== 4) {
                errorMsg.textContent = '請輸入4位數字（格式：MMDD）';
                errorMsg.classList.remove('hidden');
                return;
            }

            // 驗證輸入是否為數字
            if (!/^\d{4}$/.test(inputValue)) {
                errorMsg.textContent = '請輸入有效的數字';
                errorMsg.classList.remove('hidden');
                return;
            }

            // 解析輸入的日期
            const month = parseInt(inputValue.substring(0, 2));
            const day = parseInt(inputValue.substring(2, 4));

            // 驗證月份和日期
            if (month < 1 || month > 12) {
                errorMsg.textContent = '月份必須在 01-12 之間';
                errorMsg.classList.remove('hidden');
                return;
            }

            if (day < 1 || day > 31) {
                errorMsg.textContent = '日期必須在 01-31 之間';
                errorMsg.classList.remove('hidden');
                return;
            }

            // 開發者模式下不需要驗證日期，否則檢查是否與今天匹配
            if (!developerMode) {
            const today = new Date();
            const todayMonth = today.getMonth() + 1;
            const todayDay = today.getDate();

            if (month !== todayMonth || day !== todayDay) {
                errorMsg.textContent = `日期不正確！請輸入今天的日期：${todayMonth.toString().padStart(2, '0')}${todayDay.toString().padStart(2, '0')}`;
                errorMsg.classList.remove('hidden');
                return;
                }
            }

            // 解鎖成功
            unlockDate(unlockModalDateKey);
            closeUnlockModal();

            // 重新渲染月曆
            renderCalendar();

            // 解鎖成功後，自動領取語錄並生成圖片（開發者模式下可以解鎖任何日期）
            claimDailyQuoteWithImage();
        }

        // API Key 管理
        function openApiKeyModal() {
            document.getElementById('apiKeyModal').classList.remove('hidden');
            document.getElementById('geminiApiKeyInput').value = geminiApiKey;
            document.getElementById('geminiApiKeyInput').focus();
        }

        function closeApiKeyModal() {
            document.getElementById('apiKeyModal').classList.add('hidden');
        }

        function saveApiKey() {
            const input = document.getElementById('geminiApiKeyInput');
            geminiApiKey = input.value.trim();
            localStorage.setItem('geminiApiKey', geminiApiKey);
            closeApiKeyModal();
            alert('API Key 已保存！');
        }

        // 支援 Enter 鍵解鎖
        document.addEventListener('DOMContentLoaded', function() {
            const unlockInput = document.getElementById('unlockDateInput');
            if (unlockInput) {
                unlockInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        confirmUnlockDate();
                    }
                });
            }
        });

        // 獲取今日日期字串 (YYYY-MM-DD)
        function getTodayKey() {
            const today = new Date();
            return formatDateKey(today);
        }

        // IndexedDB 圖片存儲管理
        let imageDB = null;
        const DB_NAME = 'QuoteImagesDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'images';

        // 初始化 IndexedDB
        function initImageDB() {
            return new Promise((resolve, reject) => {
                if (imageDB) {
                    resolve(imageDB);
                    return;
                }

                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => {
                    console.error('IndexedDB 初始化失敗:', request.error);
                    reject(request.error);
                };

                request.onsuccess = () => {
                    imageDB = request.result;
                    resolve(imageDB);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'key' });
                        objectStore.createIndex('dateKey', 'dateKey', { unique: false });
                    }
                };
            });
        }

        // 將圖片保存到 IndexedDB
        async function saveImageToDB(dateKey, imageBase64) {
            try {
                if (!imageBase64) return null;

                const db = await initImageDB();
                const imageKey = `${currentUserId}_${dateKey}`;

                // 轉換 base64 為 Blob 以減少存儲空間
                const base64Data = imageBase64.startsWith('data:')
                    ? imageBase64.split(',')[1]
                    : imageBase64;

                // 根據數據前綴判斷圖片類型
                const isJPEG = base64Data.length > 0 && base64Data.charAt(0) !== 'i'; // JPEG base64 通常不以 'i' 開頭
                const blob = await (async () => {
                    const byteCharacters = atob(base64Data);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    return new Blob([byteArray], { type: isJPEG ? 'image/jpeg' : 'image/png' });
                })();

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);

                    const request = store.put({
                        key: imageKey,
                        dateKey: dateKey,
                        userId: currentUserId,
                        blob: blob,
                        timestamp: Date.now()
                    });

                    request.onsuccess = () => {
                        resolve(imageKey);
                    };

                    request.onerror = () => {
                        console.error('保存圖片到 IndexedDB 失敗:', request.error);
                        reject(request.error);
                    };
                });
            } catch (error) {
                console.error('保存圖片到 IndexedDB 時發生錯誤:', error);
                return null;
            }
        }

        // 從 IndexedDB 讀取圖片
        async function loadImageFromDB(imageKey) {
            try {
                if (!imageKey) return null;

                const db = await initImageDB();

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get(imageKey);

                    request.onsuccess = () => {
                        const result = request.result;
                        if (result && result.blob) {
                            // 將 Blob 轉換為 base64
                            const reader = new FileReader();
                            reader.onload = () => {
                                resolve(reader.result);
                            };
                            reader.onerror = () => {
                                reject(reader.error);
                            };
                            reader.readAsDataURL(result.blob);
                        } else {
                            resolve(null);
                        }
                    };

                    request.onerror = () => {
                        console.error('從 IndexedDB 讀取圖片失敗:', request.error);
                        reject(request.error);
                    };
                });
            } catch (error) {
                console.error('從 IndexedDB 讀取圖片時發生錯誤:', error);
                return null;
            }
        }

        // 從 IndexedDB 刪除圖片
        async function deleteImageFromDB(imageKey) {
            try {
                if (!imageKey) return;

                const db = await initImageDB();

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.delete(imageKey);

                    request.onsuccess = () => {
                        resolve();
                    };

                    request.onerror = () => {
                        console.error('從 IndexedDB 刪除圖片失敗:', request.error);
                        reject(request.error);
                    };
                });
            } catch (error) {
                console.error('從 IndexedDB 刪除圖片時發生錯誤:', error);
            }
        }

        // 清理舊圖片（基於日期）
        async function cleanupOldImages(keepDays = 30) {
            try {
                const db = await initImageDB();
                const today = new Date();
                const cutoffDate = new Date(today);
                cutoffDate.setDate(today.getDate() - keepDays);
                const cutoffTimestamp = cutoffDate.getTime();

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const index = store.index('dateKey');
                    const request = index.openCursor();

                    let deletedCount = 0;

                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            const item = cursor.value;
                            // 解析日期鍵或使用時間戳
                            if (item.timestamp && item.timestamp < cutoffTimestamp) {
                                cursor.delete();
                                deletedCount++;
                            } else if (item.dateKey) {
                                const [year, month, day] = item.dateKey.split('-').map(Number);
                                const itemDate = new Date(year, month - 1, day);
                                if (itemDate < cutoffDate) {
                                    cursor.delete();
                                    deletedCount++;
                                }
                            }
                            cursor.continue();
                        } else {
                            if (deletedCount > 0) {
                                console.log(`已清理 ${deletedCount} 張舊圖片`);
                            }
                            resolve(deletedCount);
                        }
                    };

                    request.onerror = () => {
                        reject(request.error);
                    };
                });
            } catch (error) {
                console.error('清理舊圖片時發生錯誤:', error);
                return 0;
            }
        }

        // 載入每日語錄記錄（從 localStorage，圖片引用從 IndexedDB 載入）
        async function loadDailyQuotes() {
            const key = `dailyQuotes_${currentUserId}`;
            const quotesData = JSON.parse(localStorage.getItem(key) || '{}');

            // 異步載入圖片（如果需要的話）
            // 這裡先返回數據結構，圖片在顯示時再載入
            return quotesData;
        }

        // 同步版本（用於不需要異步的地方）
        function loadDailyQuotesSync() {
            const key = `dailyQuotes_${currentUserId}`;
            return JSON.parse(localStorage.getItem(key) || '{}');
        }

        // 壓縮圖片數據（降低質量以減少存儲空間）
        function compressImageBase64(imageBase64, quality = 0.6, maxWidth = 600) {
            return new Promise((resolve, reject) => {
                if (!imageBase64 || imageBase64.trim() === '') {
                    resolve('');
                    return;
                }

                const img = new Image();
                let timeoutId;

                // 設置超時（10秒）
                timeoutId = setTimeout(() => {
                    reject(new Error('圖片壓縮超時'));
                }, 10000);

                img.onload = function() {
                    clearTimeout(timeoutId);

                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        // 計算新尺寸（保持比例，降低到更小的尺寸以節省空間）
                        let width = img.width;
                        let height = img.height;
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }

                        canvas.width = width;
                        canvas.height = height;

                        // 繪製並壓縮
                        ctx.drawImage(img, 0, 0, width, height);

                        // 轉換為 JPEG 格式（通常比 PNG 小，使用較低的質量）
                        const compressed = canvas.toDataURL('image/jpeg', quality);
                        // 移除 data:image/jpeg;base64, 前綴
                        resolve(compressed.split(',')[1]);
                    } catch (error) {
                        reject(error);
                    }
                };

                img.onerror = () => {
                    clearTimeout(timeoutId);
                    // 如果壓縮失敗，返回原數據（移除前綴）
                    resolve(imageBase64.startsWith('data:') ? imageBase64.split(',')[1] : imageBase64);
                };

                // 處理 base64 圖片
                const imageSrc = imageBase64.startsWith('data:')
                    ? imageBase64
                    : `data:image/png;base64,${imageBase64}`;
                img.src = imageSrc;
            });
        }

        // 清理舊的語錄數據（只保留最近 N 天的完整數據，其他的移除圖片引用）
        async function cleanupOldQuoteData(quotesData, keepDays = 30) {
            const today = new Date();
            const cutoffDate = new Date(today);
            cutoffDate.setDate(today.getDate() - keepDays);

            const cleanedData = {};
            let removedCount = 0;

            for (const dateKey in quotesData) {
                const quote = quotesData[dateKey];
                if (!quote) continue;

                // 解析日期
                const [year, month, day] = dateKey.split('-').map(Number);
                const quoteDate = new Date(year, month - 1, day);

                if (quoteDate >= cutoffDate) {
                    // 保留最近 N 天的完整數據
                    cleanedData[dateKey] = quote;
                } else {
                    // 移除舊數據的圖片引用，並從 IndexedDB 刪除圖片
                    if (quote.imageKey) {
                        try {
                            await deleteImageFromDB(quote.imageKey);
                        } catch (error) {
                            console.warn(`刪除舊圖片失敗 (${dateKey}):`, error);
                        }
                    }

                    // 只保留文字和日期
                    cleanedData[dateKey] = {
                        quote: quote.quote,
                        date: quote.date,
                        imageKey: null,
                        hasImage: false
                    };
                    removedCount++;
                }
            }

            if (removedCount > 0) {
                console.log(`已清理 ${removedCount} 條舊語錄的圖片數據`);
            }

            return cleanedData;
        }

        // 同步版本（用於不需要異步清理的場合）
        function cleanupOldQuoteDataSync(quotesData, keepDays = 30) {
            const today = new Date();
            const cutoffDate = new Date(today);
            cutoffDate.setDate(today.getDate() - keepDays);

            const cleanedData = {};
            let removedCount = 0;

            for (const dateKey in quotesData) {
                const quote = quotesData[dateKey];
                if (!quote) continue;

                const [year, month, day] = dateKey.split('-').map(Number);
                const quoteDate = new Date(year, month - 1, day);

                if (quoteDate >= cutoffDate) {
                    cleanedData[dateKey] = quote;
                } else {
                    cleanedData[dateKey] = {
                        quote: quote.quote,
                        date: quote.date,
                        imageKey: null,
                        hasImage: false
                    };
                    removedCount++;
                }
            }

            return cleanedData;
        }

        // 估算 JSON 字串大小（以字節為單位）
        function estimateStorageSize(data) {
            return new Blob([JSON.stringify(data)]).size;
        }

        // 保存每日語錄記錄（使用 IndexedDB 存儲圖片）
        async function saveDailyQuotes(quotesData, newDateKey = null) {
            const key = `dailyQuotes_${currentUserId}`;

            try {
                // 初始化 IndexedDB
                await initImageDB();

                // 先載入現有數據
                const existingData = loadDailyQuotesSync();

                // 先清理舊數據
                const cleanedExistingData = cleanupOldQuoteData(existingData, 30);

                // 合併數據
                const mergedData = { ...cleanedExistingData };

                // 處理新數據或更新的數據
                const processedData = {};
                for (const dateKey in quotesData) {
                    const quote = quotesData[dateKey];
                    if (!quote) continue;

                    const existingQuote = mergedData[dateKey];

                    // 檢查是否有新圖片需要保存到 IndexedDB
                    if (quote.image && (!existingQuote || !existingQuote.imageKey || existingQuote.image !== quote.image)) {
                        // 壓縮圖片後保存到 IndexedDB
                        try {
                            let imageToSave = quote.image;

                            // 壓縮圖片
                            const imageSize = quote.image.length;
                            if (imageSize > 100000) {
                                imageToSave = await compressImageBase64(quote.image);
                            } else {
                                imageToSave = quote.image.startsWith('data:')
                                    ? quote.image.split(',')[1]
                                    : quote.image;
                            }

                            // 保存到 IndexedDB
                            const imageKey = await saveImageToDB(dateKey, imageToSave);

                            processedData[dateKey] = {
                                quote: quote.quote,
                                date: quote.date,
                                imageKey: imageKey, // 只保存引用，不保存圖片數據
                                hasImage: true
                            };
                        } catch (error) {
                            console.warn(`保存圖片到 IndexedDB 失敗 (${dateKey}):`, error);
                            // 如果保存失敗，仍然保存文字
                            processedData[dateKey] = {
                                quote: quote.quote,
                                date: quote.date,
                                imageKey: null,
                                hasImage: false
                            };
                        }
                    } else if (existingQuote) {
                        // 使用現有數據
                        processedData[dateKey] = existingQuote;
                    } else {
                        // 只有文字，沒有圖片
                        processedData[dateKey] = {
                            quote: quote.quote,
                            date: quote.date,
                            imageKey: null,
                            hasImage: false
                        };
                    }
                }

                // 合併處理後的數據
                const finalData = { ...mergedData, ...processedData };

                // 再次清理（確保不超過限制）
                const finalCleanedData = cleanupOldQuoteDataSync(finalData, 30);

                // 清理 IndexedDB 中的舊圖片
                await cleanupOldImages(30);

                // 保存到 localStorage（只包含文字和引用）
                localStorage.setItem(key, JSON.stringify(finalCleanedData));

                console.log('語錄數據已保存（圖片存儲在 IndexedDB）');
            } catch (error) {
                console.error('保存語錄時發生錯誤:', error);

                // 如果 IndexedDB 失敗，嘗試使用 localStorage（但不推薦，空間有限）
                try {
                    const fallbackData = {};
                    for (const dateKey in quotesData) {
                        const quote = quotesData[dateKey];
                        if (quote) {
                            fallbackData[dateKey] = {
                                quote: quote.quote,
                                date: quote.date,
                                imageKey: null,
                                hasImage: false
                            };
                        }
                    }
                    localStorage.setItem(key, JSON.stringify(fallbackData));
                    alert('⚠️ IndexedDB 不可用，已保存文字數據。圖片未保存。');
                } catch (e) {
                    console.error('無法保存數據:', e);
                    alert('❌ 無法保存數據。請檢查瀏覽器存儲權限。');
                }
            }
        }

        // 獲取今日語錄（如果已領取）
        function getTodayQuote() {
            const quotesData = loadDailyQuotes();
            const todayKey = getTodayKey();
            return quotesData[todayKey] || null;
        }

        // 領取今日語錄（開發者模式下不需要解鎖）
        function claimDailyQuote() {
            const todayKey = getTodayKey();

            // 檢查是否已解鎖（開發者模式下跳過檢查）
            if (!checkDateUnlocked(todayKey)) {
                alert('請先解鎖今天的日期！點擊月曆上的鎖圖標解鎖。\n\n💡 提示：雙擊標題可開啟開發者模式');
                return;
            }

            claimDailyQuoteWithImage();
        }

        // 開發者模式：直接打卡指定日期（不需要解鎖）
        async function devModeCheckin(dateKey) {
            if (!developerMode) {
                alert('請先開啟開發者模式（雙擊標題）');
                return;
            }

            // 自動解鎖該日期
            unlockDate(dateKey);

            // 直接生成語錄
            await claimDailyQuoteForDate(dateKey);
        }

        // 為指定日期領取語錄（開發者模式專用）
        async function claimDailyQuoteForDate(dateKey) {
            const quotesData = loadDailyQuotes();

            // 如果該日期已經領取過，不重複領取
            if (quotesData[dateKey] && quotesData[dateKey].image) {
                const quote = quotesData[dateKey];
                // 確保已加入到待辦事項
                if (quote.quote && quote.image) {
                    if (!todos[dateKey]) {
                        todos[dateKey] = [];
                    }
                    const exists = todos[dateKey].some(todo => {
                        if (typeof todo === 'string') return false;
                        return todo.isDailyQuote === true && todo.text === quote.quote;
                    });
                    if (!exists) {
                        await addDailyQuoteToTodos(dateKey, quote.quote, quote.image);
                    }
                }
                renderDailyQuote(dateKey).catch(err => console.error('渲染語錄失敗:', err));
                return;
            }

            // 從未使用的語錄中隨機選擇
            const selectedQuote = await selectRandomQuote();

            // 顯示載入狀態
            const card = document.getElementById('dailyQuoteCard');
            if (card) {
                card.innerHTML = `
                    <div class="text-center py-4">
                        <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-purple-600 mb-2"></div>
                        <p class="text-gray-600">正在生成語錄卡片...</p>
                    </div>
                `;
            }

            try {
                // 生成圖片
                let imageBase64 = null;
                try {
                    imageBase64 = await generateQuoteImageWithCanvas(selectedQuote, dateKey);
                } catch (error) {
                    console.warn('Canvas 圖片生成失敗:', error);
                    if (geminiApiKey) {
                        try {
                            imageBase64 = await generateQuoteImageWithGemini(selectedQuote);
                        } catch (apiError) {
                            console.warn('Gemini API 圖片生成失敗:', apiError);
                        }
                    }
                }

                // 準備保存語錄（圖片稍後在 saveDailyQuotes 中處理）
                const currentQuotesData = loadDailyQuotes();
                currentQuotesData[dateKey] = {
                    quote: selectedQuote,
                    date: dateKey,
                    image: imageBase64 || null // 保存原始 base64，讓 saveDailyQuotes 處理壓縮
                };
                await saveDailyQuotes(currentQuotesData, dateKey);

                // 自動將語錄加入到待辦事項中（即使沒有圖片也要添加）
                // 如果圖片為 null，addDailyQuoteToTodos 會使用預設顏色
                await addDailyQuoteToTodos(dateKey, selectedQuote, imageBase64 || '');

                // 更新顯示
                if (selectedDate && formatDateKey(selectedDate) === dateKey) {
                    renderDailyQuote(dateKey);
                    renderTodos(dateKey);
                } else {
                    const date = new Date(dateKey);
                    selectDate(date);
                }

                renderCalendar();
            } catch (error) {
                console.error('生成語錄失敗:', error);
                console.error('錯誤詳情:', error.stack || error.message);
                // 即使出錯，也嘗試保存語錄（不包含圖片）
                try {
                    quotesData[dateKey] = {
                        quote: selectedQuote,
                        date: dateKey,
                        image: null
                    };
                    await saveDailyQuotes(quotesData);
                    // 嘗試添加待辦事項（使用預設顏色）
                    await addDailyQuoteToTodos(dateKey, selectedQuote, '');
                } catch (saveError) {
                    console.error('保存語錄也失敗:', saveError);
                }

                if (card) {
                    card.innerHTML = `
                        <div class="text-center py-4">
                            <p class="text-red-600 mb-2">圖片生成失敗</p>
                            <p class="text-xs text-gray-500 mb-3">語錄已保存，但圖片生成失敗。請查看控制台了解詳情。</p>
                            <button onclick="devModeCheckin('${dateKey}')"
                                    class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">
                                重試生成圖片
                            </button>
                        </div>
                    `;
                }
                // 重新渲染月曆和待辦事項
                renderCalendar();
                if (selectedDate && formatDateKey(selectedDate) === dateKey) {
                    renderDailyQuote(dateKey);
                    renderTodos(dateKey);
                }
            }
        }

        // 獲取已使用的語錄列表
        function getUsedQuotes() {
            const key = `usedQuotes_${currentUserId}`;
            return JSON.parse(localStorage.getItem(key) || '[]');
        }

        // 保存已使用的語錄列表
        function saveUsedQuotes(usedQuotes) {
            const key = `usedQuotes_${currentUserId}`;
            localStorage.setItem(key, JSON.stringify(usedQuotes));
        }

        // 獲取已使用的顏色主題列表（按日期）
        function getUsedThemes() {
            const key = `usedThemes_${currentUserId}`;
            return JSON.parse(localStorage.getItem(key) || '{}');
        }

        // 保存已使用的顏色主題列表
        function saveUsedThemes(usedThemes) {
            const key = `usedThemes_${currentUserId}`;
            localStorage.setItem(key, JSON.stringify(usedThemes));
        }

        // 獲取未使用的主題（確保每天顏色不重複）
        function getUnusedTheme(dateKey) {
            const usedThemes = getUsedThemes();
            const allThemeNames = ['寧靜湖面', '溫暖晨曦', '夢幻花園', '清新原野', '堅韌山巒', '深邃夜空', '歡樂煙火', '溫柔月光'];

            // 獲取所有已使用的主題名稱
            const usedThemeNames = Object.values(usedThemes);

            // 如果所有主題都用過了，重置記錄（保留今天的）
            let availableThemes = allThemeNames.filter(name => !usedThemeNames.includes(name));
            if (availableThemes.length === 0) {
                // 保留今天的主題，清除其他的
                const todayKey = getTodayKey();
                const todayTheme = usedThemes[todayKey];
                const newUsedThemes = {};
                if (todayTheme) {
                    newUsedThemes[todayKey] = todayTheme;
                }
                saveUsedThemes(newUsedThemes);
                availableThemes = allThemeNames.filter(name => name !== todayTheme);
            }

            // 隨機選擇一個未使用的主題
            const selectedTheme = availableThemes[Math.floor(Math.random() * availableThemes.length)];

            // 記錄今天使用的主題
            usedThemes[dateKey] = selectedTheme;
            saveUsedThemes(usedThemes);

            return selectedTheme;
        }

        // 選擇一個未使用過的語錄（確保每天都不一樣）
        async function selectRandomQuote() {
            const currentQuotes = await getDailyQuotes(); // 每次獲取最新的語錄列表
            const usedQuotes = getUsedQuotes();
            const availableQuotes = currentQuotes.filter(quote => !usedQuotes.includes(quote));

            // 如果所有語錄都用過了，重置記錄
            if (availableQuotes.length === 0) {
                saveUsedQuotes([]);
                return currentQuotes[Math.floor(Math.random() * currentQuotes.length)];
            }

            // 從未使用的語錄中隨機選擇
            const randomIndex = Math.floor(Math.random() * availableQuotes.length);
            const selectedQuote = availableQuotes[randomIndex];

            // 記錄已使用的語錄
            usedQuotes.push(selectedQuote);
            saveUsedQuotes(usedQuotes);

            return selectedQuote;
        }

        // 領取語錄並生成圖片
        async function claimDailyQuoteWithImage() {
            const todayKey = getTodayKey();
            const quotesData = loadDailyQuotes();

            // 如果今天已經領取過，不重複領取
            if (quotesData[todayKey] && quotesData[todayKey].image) {
                renderDailyQuote().catch(err => console.error('渲染語錄失敗:', err));
                // 確保已加入到待辦事項（只在不存在時添加）
                const quote = quotesData[todayKey];
                if (quote.quote && quote.image) {
                    // 檢查是否已經存在，避免重複添加
                    if (!todos[todayKey]) {
                        todos[todayKey] = [];
                    }
                    const exists = todos[todayKey].some(todo => {
                        if (typeof todo === 'string') return false; // 字串格式不可能是語錄
                        return todo.isDailyQuote === true && todo.text === quote.quote;
                    });
                    if (!exists) {
                        addDailyQuoteToTodos(todayKey, quote.quote, quote.image);
                    }
                }
                return;
            }

            // 從未使用的語錄中隨機選擇，確保每天都不一樣
            const selectedQuote = await selectRandomQuote();

            // 顯示載入狀態
            const card = document.getElementById('dailyQuoteCard');
            card.innerHTML = `
                <div class="text-center py-4">
                    <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-purple-600 mb-2"></div>
                    <p class="text-gray-600">正在生成語錄卡片...</p>
                </div>
            `;

            try {
                // 生成圖片（優先使用 html2canvas，如果失敗則嘗試 Gemini API）
                let imageBase64 = null;

                // 方法1：使用 html2canvas（不需要 API）
                try {
                    imageBase64 = await generateQuoteImageWithCanvas(selectedQuote, todayKey);
                } catch (error) {
                    console.warn('Canvas 圖片生成失敗，嘗試使用 Gemini API:', error);

                    // 方法2：如果設置了 Gemini API Key，則使用 API
                    if (geminiApiKey) {
                        try {
                            imageBase64 = await generateQuoteImageWithGemini(selectedQuote);
                        } catch (apiError) {
                            console.warn('Gemini API 圖片生成失敗:', apiError);
                        }
                    }
                }

                // 準備保存語錄（圖片稍後在 saveDailyQuotes 中處理）
                const currentQuotesData = loadDailyQuotes();
                currentQuotesData[todayKey] = {
                    quote: selectedQuote,
                    date: todayKey,
                    image: imageBase64 || null // 保存原始 base64，讓 saveDailyQuotes 處理壓縮
                };
                await saveDailyQuotes(currentQuotesData, todayKey);

                // 自動將語錄加入到待辦事項中並標記為完成
                addDailyQuoteToTodos(todayKey, selectedQuote, imageBase64);

                // 如果用戶正在查看今天的日期，更新顯示；否則自動選擇今天並顯示
                if (selectedDate && formatDateKey(selectedDate) === todayKey) {
                    renderDailyQuote(todayKey).catch(err => console.error('渲染語錄失敗:', err));
                    renderTodos(todayKey);
                } else {
                    // 自動選擇今天的日期以顯示語錄
                    const today = new Date();
                    selectDate(today);
                }

                // 更新月曆顯示
                renderCalendar();
            } catch (error) {
                console.error('領取語錄失敗:', error);
                card.innerHTML = `
                    <div class="text-center py-4">
                        <p class="text-red-600 mb-2">領取失敗，請重試</p>
                        <button onclick="claimDailyQuoteWithImage()"
                                class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">
                            重試
                        </button>
                    </div>
                `;
            }
        }

        // 分析語錄意境，根據心境生成對應的視覺景致（確保每天顏色不重複）
        function getQuoteTheme(quote, dateKey) {
            const quoteLower = quote.toLowerCase();

            // 檢查今天是否已經有主題
            const usedThemes = getUsedThemes();
            if (usedThemes[dateKey]) {
                // 如果今天已有主題，直接返回該主題
                const themeName = usedThemes[dateKey];
                const allThemes = getAllThemes();
                return allThemes.find(t => t.name === themeName) || allThemes[0];
            }

            // 定義關鍵詞與對應的意境主題
            const moodKeywords = {
                // 平靜、寧靜、內省
                peaceful: {
                    keywords: ['平靜', '寧靜', '內心', '原諒', '接受', '平凡', '穩定', '情緒穩定', '平靜', '安靜', '沉靜'],
                    theme: {
                        name: '寧靜湖面',
                        gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 30%, #4facfe 60%, #00f2fe 100%)',
                        accent: '#00f2fe',
                        decor: '🌊',
                        pattern: 'wave',
                        description: '如平靜湖面般的寧靜藍紫色調'
                    }
                },
                // 溫暖、希望、鼓勵
                warm: {
                    keywords: ['開心', '快樂', '希望', '期待', '更好', '成長', '進步', '加油', '努力', '勇敢', '堅持'],
                    theme: {
                        name: '溫暖晨曦',
                        gradient: 'linear-gradient(135deg, #f093fb 0%, #f5576c 30%, #f6d365 60%, #fee140 100%)',
                        accent: '#fee140',
                        decor: '🌅',
                        pattern: 'star',
                        description: '如晨曦般溫暖的橙金色調'
                    }
                },
                // 夢幻、溫柔、美好
                dreamy: {
                    keywords: ['夢想', '美好', '溫柔', '愛', '感覺', '期待', '浪漫', '美好', '溫柔', '夢幻'],
                    theme: {
                        name: '夢幻花園',
                        gradient: 'linear-gradient(135deg, #fa709a 0%, #fee140 30%, #f093fb 60%, #667eea 100%)',
                        accent: '#f093fb',
                        decor: '🌸',
                        pattern: 'star',
                        description: '如夢幻花園般的粉紫色調'
                    }
                },
                // 清新、自由、開闊
                fresh: {
                    keywords: ['自由', '開闊', '清新', '自然', '呼吸', '放鬆', '輕鬆', '自由', '開闊', '廣闊'],
                    theme: {
                        name: '清新原野',
                        gradient: 'linear-gradient(135deg, #30cfd0 0%, #4facfe 30%, #00f2fe 60%, #667eea 100%)',
                        accent: '#30cfd0',
                        decor: '🌿',
                        pattern: 'leaf',
                        description: '如原野般清新的青藍色調'
                    }
                },
                // 力量、堅強、決心
                strong: {
                    keywords: ['力量', '堅強', '勇敢', '不怕', '打敗', '戰勝', '決心', '堅持', '勇敢', '堅強'],
                    theme: {
                        name: '堅韌山巒',
                        gradient: 'linear-gradient(135deg, #330867 0%, #764ba2 30%, #667eea 60%, #f093fb 100%)',
                        accent: '#764ba2',
                        decor: '⛰️',
                        pattern: 'diamond',
                        description: '如山巒般堅韌的深紫色調'
                    }
                },
                // 憂鬱、思考、深沉
                contemplative: {
                    keywords: ['憂鬱', '思考', '深沉', '失去', '痛苦', '困難', '難過', '憂愁', '思考', '深沉'],
                    theme: {
                        name: '深邃夜空',
                        gradient: 'linear-gradient(135deg, #1e3c72 0%, #2a5298 30%, #667eea 60%, #764ba2 100%)',
                        accent: '#667eea',
                        decor: '🌙',
                        pattern: 'dot',
                        description: '如夜空般深邃的藍紫色調'
                    }
                },
                // 喜悅、慶祝、成就
                joyful: {
                    keywords: ['開心', '快樂', '成功', '成就', '慶祝', '開心', '快樂', '喜悅', '歡樂', '慶祝'],
                    theme: {
                        name: '歡樂煙火',
                        gradient: 'linear-gradient(135deg, #f6d365 0%, #fda085 30%, #fa709a 60%, #f093fb 100%)',
                        accent: '#fda085',
                        decor: '🎉',
                        pattern: 'star',
                        description: '如煙火般絢爛的金粉色調'
                    }
                },
                // 溫柔、關懷、愛
                gentle: {
                    keywords: ['溫柔', '關懷', '愛', '照顧', '關心', '溫柔', '關懷', '愛', '溫暖', '體貼'],
                    theme: {
                        name: '溫柔月光',
                        gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 30%, #f093fb 60%, #fa709a 100%)',
                        accent: '#f093fb',
                        decor: '💜',
                        pattern: 'circle',
                        description: '如月光般溫柔的紫粉色調'
                    }
                }
            };

            // 分析語錄，找出匹配的意境
            let matchedMood = null;
            let maxScore = 0;

            for (const [mood, data] of Object.entries(moodKeywords)) {
                let score = 0;
                data.keywords.forEach(keyword => {
                    if (quoteLower.includes(keyword)) {
                        score += keyword.length; // 關鍵詞越長，權重越高
                    }
                });
                if (score > maxScore) {
                    maxScore = score;
                    matchedMood = data.theme;
                }
            }

            // 如果沒有匹配到，根據語錄的整體情感傾向選擇
            if (!matchedMood || maxScore === 0) {
                // 分析語錄的整體情感
                const hasPositive = /開心|快樂|希望|美好|成功|成長|進步|勇敢|堅持|努力/.test(quoteLower);
                const hasNegative = /憂鬱|痛苦|困難|失去|難過|憂愁|失望/.test(quoteLower);
                const hasNeutral = /平靜|寧靜|接受|平凡|穩定|情緒/.test(quoteLower);

                if (hasPositive && !hasNegative) {
                    matchedMood = moodKeywords.warm.theme;
                } else if (hasNegative && !hasPositive) {
                    matchedMood = moodKeywords.contemplative.theme;
                } else if (hasNeutral) {
                    matchedMood = moodKeywords.peaceful.theme;
                } else {
                    // 默認使用溫柔主題
                    matchedMood = moodKeywords.gentle.theme;
                }
            }

            // 確保主題不重複
            const selectedThemeName = getUnusedTheme(dateKey);
            // 如果匹配的主題已經用過，使用未使用的主題
            if (matchedMood && matchedMood.name === selectedThemeName) {
            return matchedMood;
            } else {
                // 使用未使用的主題
                const allThemes = getAllThemes();
                return allThemes.find(t => t.name === selectedThemeName) || matchedMood;
            }
        }

        // 獲取所有主題列表（用於查找）
        function getAllThemes() {
            return [
                {
                    name: '寧靜湖面',
                    gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 30%, #4facfe 60%, #00f2fe 100%)',
                    accent: '#00f2fe',
                    decor: '🌊',
                    pattern: 'wave'
                },
                {
                    name: '溫暖晨曦',
                    gradient: 'linear-gradient(135deg, #f093fb 0%, #f5576c 30%, #f6d365 60%, #fee140 100%)',
                    accent: '#fee140',
                    decor: '🌅',
                    pattern: 'star'
                },
                {
                    name: '夢幻花園',
                    gradient: 'linear-gradient(135deg, #fa709a 0%, #fee140 30%, #f093fb 60%, #667eea 100%)',
                    accent: '#f093fb',
                    decor: '🌸',
                    pattern: 'star'
                },
                {
                    name: '清新原野',
                    gradient: 'linear-gradient(135deg, #30cfd0 0%, #4facfe 30%, #00f2fe 60%, #667eea 100%)',
                    accent: '#30cfd0',
                    decor: '🌿',
                    pattern: 'leaf'
                },
                {
                    name: '堅韌山巒',
                    gradient: 'linear-gradient(135deg, #330867 0%, #764ba2 30%, #667eea 60%, #f093fb 100%)',
                    accent: '#764ba2',
                    decor: '⛰️',
                    pattern: 'diamond'
                },
                {
                    name: '深邃夜空',
                    gradient: 'linear-gradient(135deg, #1e3c72 0%, #2a5298 30%, #667eea 60%, #764ba2 100%)',
                    accent: '#667eea',
                    decor: '🌙',
                    pattern: 'dot'
                },
                {
                    name: '歡樂煙火',
                    gradient: 'linear-gradient(135deg, #f6d365 0%, #fda085 30%, #fa709a 60%, #f093fb 100%)',
                    accent: '#fda085',
                    decor: '🎉',
                    pattern: 'star'
                },
                {
                    name: '溫柔月光',
                    gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 30%, #f093fb 60%, #fa709a 100%)',
                    accent: '#f093fb',
                    decor: '💜',
                    pattern: 'circle'
                }
            ];
        }

        // 使用 html2canvas 生成語錄卡片圖片（不需要 API，只生成背景，不含文字）
        async function generateQuoteImageWithCanvas(quote, dateKey) {
            const theme = getQuoteTheme(quote, dateKey);

            // 創建一個臨時的卡片元素
            const tempCard = document.createElement('div');
            tempCard.style.position = 'fixed';
            tempCard.style.left = '-9999px';
            tempCard.style.width = '1000px';
            tempCard.style.height = '700px';
            tempCard.style.padding = '0';
            tempCard.style.background = theme.gradient;
            tempCard.style.borderRadius = '30px';
            tempCard.style.boxShadow = '0 30px 80px rgba(0,0,0,0.4)';
            tempCard.style.display = 'flex';
            tempCard.style.flexDirection = 'column';
            tempCard.style.justifyContent = 'center';
            tempCard.style.alignItems = 'center';
            tempCard.style.color = 'white';
            tempCard.style.fontFamily = "'Inter', sans-serif";
            tempCard.style.overflow = 'hidden';
            tempCard.style.position = 'relative';

            // 添加背景裝飾圖案
            const bgPattern = document.createElement('div');
            bgPattern.style.position = 'absolute';
            bgPattern.style.top = '0';
            bgPattern.style.left = '0';
            bgPattern.style.width = '100%';
            bgPattern.style.height = '100%';
            bgPattern.style.opacity = '0.15';
            bgPattern.style.backgroundImage = createPatternSVG(theme.pattern, theme.accent);
            bgPattern.style.backgroundRepeat = 'repeat';
            bgPattern.style.backgroundSize = '200px 200px';
            tempCard.appendChild(bgPattern);

            // 添加光暈效果
            const glow1 = document.createElement('div');
            glow1.style.position = 'absolute';
            glow1.style.top = '-100px';
            glow1.style.right = '-100px';
            glow1.style.width = '400px';
            glow1.style.height = '400px';
            glow1.style.borderRadius = '50%';
            glow1.style.background = `radial-gradient(circle, ${theme.accent}40 0%, transparent 70%)`;
            glow1.style.filter = 'blur(60px)';
            tempCard.appendChild(glow1);

            const glow2 = document.createElement('div');
            glow2.style.position = 'absolute';
            glow2.style.bottom = '-150px';
            glow2.style.left = '-150px';
            glow2.style.width = '500px';
            glow2.style.height = '500px';
            glow2.style.borderRadius = '50%';
            glow2.style.background = `radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%)`;
            glow2.style.filter = 'blur(80px)';
            tempCard.appendChild(glow2);

            // 不添加文字內容，只保留背景和裝飾

            // 根據意境添加額外的視覺元素
            if (theme.name.includes('湖面') || theme.name.includes('原野')) {
                // 添加水平線條，模擬地平線
                const horizonLine = document.createElement('div');
                horizonLine.style.position = 'absolute';
                horizonLine.style.bottom = '150px';
                horizonLine.style.left = '0';
                horizonLine.style.width = '100%';
                horizonLine.style.height = '2px';
                horizonLine.style.background = `linear-gradient(90deg, transparent, ${theme.accent}60, transparent)`;
                horizonLine.style.opacity = '0.4';
                tempCard.appendChild(horizonLine);
            }

            if (theme.name.includes('夜空') || theme.name.includes('月光')) {
                // 添加星星點點
                for (let i = 0; i < 5; i++) {
                    const star = document.createElement('div');
                    star.style.position = 'absolute';
                    star.style.top = `${20 + i * 15}%`;
                    star.style.left = `${10 + i * 18}%`;
                    star.style.width = '4px';
                    star.style.height = '4px';
                    star.style.background = 'white';
                    star.style.borderRadius = '50%';
                    star.style.opacity = '0.6';
                    star.style.boxShadow = '0 0 6px white';
                    tempCard.appendChild(star);
                }
            }

            if (theme.name.includes('煙火') || theme.name.includes('晨曦')) {
                // 添加光線效果
                const lightRay = document.createElement('div');
                lightRay.style.position = 'absolute';
                lightRay.style.top = '0';
                lightRay.style.left = '50%';
                lightRay.style.width = '200px';
                lightRay.style.height = '100%';
                lightRay.style.background = `linear-gradient(180deg, ${theme.accent}30 0%, transparent 100%)`;
                lightRay.style.transform = 'translateX(-50%)';
                lightRay.style.filter = 'blur(40px)';
                tempCard.appendChild(lightRay);
            }

            document.body.appendChild(tempCard);

            try {
                // 確保元素已添加到 DOM（等待一小段時間讓瀏覽器渲染）
                await new Promise(resolve => setTimeout(resolve, 100));

                // 使用 html2canvas 轉換為圖片（降低 scale 以減少圖片大小）
                const canvas = await html2canvas(tempCard, {
                    width: 1000,
                    height: 700,
                    scale: 1.5, // 降低 scale 從 2 到 1.5，減少圖片大小
                    backgroundColor: null,
                    useCORS: true,
                    logging: false,
                    allowTaint: false,
                    removeContainer: true // 自動移除臨時容器
                });

                // 轉換為 base64
                const base64 = canvas.toDataURL('image/png');

                // 移除臨時元素
                if (tempCard.parentNode) {
                document.body.removeChild(tempCard);
                }

                // 檢查生成的圖片是否有效
                if (!base64 || base64.length < 100) {
                    throw new Error('生成的圖片數據無效或過小');
                }

                // 返回 base64（去掉 data:image/png;base64, 前綴）
                return base64.split(',')[1];
            } catch (error) {
                // 確保移除臨時元素
                if (tempCard.parentNode) {
                    try {
                    document.body.removeChild(tempCard);
                    } catch (e) {
                        console.warn('移除臨時元素失敗:', e);
                    }
                }

                // 提供更詳細的錯誤信息
                console.error('html2canvas 生成失敗:', {
                    error: error.message,
                    stack: error.stack,
                    dateKey: dateKey
                });

                throw new Error(`圖片生成失敗: ${error.message || '未知錯誤'}`);
            }
        }

        // 創建背景圖案 SVG
        function createPatternSVG(patternType, color) {
            const svgPatterns = {
                circle: `url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='50' cy='50' r='20' fill='${encodeURIComponent(color)}' opacity='0.3'/%3E%3C/svg%3E")`,
                wave: `url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0,50 Q25,30 50,50 T100,50' stroke='${encodeURIComponent(color)}' fill='none' stroke-width='2' opacity='0.3'/%3E%3C/svg%3E")`,
                dot: `url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='20' cy='20' r='3' fill='${encodeURIComponent(color)}' opacity='0.4'/%3E%3Ccircle cx='80' cy='80' r='3' fill='${encodeURIComponent(color)}' opacity='0.4'/%3E%3C/svg%3E")`,
                star: `url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpolygon points='50,10 55,35 80,35 60,50 65,75 50,60 35,75 40,50 20,35 45,35' fill='${encodeURIComponent(color)}' opacity='0.2'/%3E%3C/svg%3E")`,
                leaf: `url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M50,20 Q30,40 50,60 Q70,40 50,20' fill='${encodeURIComponent(color)}' opacity='0.25'/%3E%3C/svg%3E")`,
                diamond: `url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpolygon points='50,10 70,50 50,90 30,50' fill='${encodeURIComponent(color)}' opacity='0.2'/%3E%3C/svg%3E")`
            };
            return svgPatterns[patternType] || svgPatterns.circle;
        }

        // 使用 Gemini API 生成語錄圖片（可選）
        async function generateQuoteImageWithGemini(quote) {
            if (!geminiApiKey) {
                throw new Error('Gemini API Key 未設定');
            }

            const prompt = `A highly aesthetic, minimalist abstract digital art background suitable for a daily quote card. Use soft, ambient lighting and colors inspired by the current time of day. Incorporate subtle elements related to inspiration or success, like a gentle upward curve or a blurred horizon. The style should be modern, serene, and clean. Resolution 1024x1024. The central theme relates to: "${quote}".`;

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${geminiApiKey}`;

            const payload = {
                instances: [{ prompt: prompt }],
                parameters: {
                    "sampleCount": 1,
                    "aspectRatio": "1:1"
                }
            };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API returned status ${response.status}`);
            }

            const result = await response.json();
            const base64Data = result.predictions?.[0]?.bytesBase64Encoded;

            if (base64Data) {
                return base64Data;
            } else {
                throw new Error("Image generation failed to return base64 data.");
            }
        }

        // 同步所有已解鎖的語錄到待辦事項
        async function syncAllQuotesToTodos() {
            const quotesData = loadDailyQuotes();

            for (const dateKey in quotesData) {
                const quote = quotesData[dateKey];
                if (quote && quote.quote && quote.image) {
                    // 檢查是否已經有這個語錄待辦事項
                    if (!todos[dateKey]) {
                        todos[dateKey] = [];
                    }

                    const existingQuoteTodo = todos[dateKey].find(todo => {
                        if (typeof todo === 'string') return false; // 字串格式不可能是語錄
                        return todo.isDailyQuote === true && todo.text === quote.quote;
                    });

                    if (!existingQuoteTodo) {
                        // 如果沒有，則添加
                        await addDailyQuoteToTodos(dateKey, quote.quote, quote.image);
                    } else if (typeof existingQuoteTodo === 'object' && !existingQuoteTodo.bgColor) {
                        // 如果存在但沒有背景顏色，重新提取顏色
                        const bgColor = await extractDominantColor(quote.image);
                        existingQuoteTodo.bgColor = bgColor;
                        existingQuoteTodo.imageBase64 = quote.image;
                        saveTodos();

                        // 如果當前選中的是這個日期，立即更新顯示
                        if (selectedDate && formatDateKey(selectedDate) === dateKey) {
                            renderTodos(dateKey);
                        }
                    }
                }
            }
        }

        // 獲取指定日期的語錄（從 IndexedDB 載入圖片）
        async function getQuoteForDate(dateKey) {
            const quotesData = await loadDailyQuotes();
            const quote = quotesData[dateKey];

            if (!quote) return null;

            // 如果有圖片引用，從 IndexedDB 載入
            if (quote.imageKey && quote.hasImage) {
                try {
                    const imageBase64 = await loadImageFromDB(quote.imageKey);
                    if (imageBase64) {
                        return {
                            ...quote,
                            image: imageBase64
                        };
                    }
                } catch (error) {
                    console.warn(`載入圖片失敗 (${dateKey}):`, error);
                }
            }

            // 兼容舊格式（直接包含圖片數據）
            if (quote.image) {
                return quote;
            }

            return {
                ...quote,
                image: null
            };
        }

        // 同步版本（返回基本數據，不載入圖片）
        function getQuoteForDateSync(dateKey) {
            const quotesData = loadDailyQuotesSync();
            return quotesData[dateKey] || null;
        }

        // 渲染每日語錄卡片（根據選中的日期或今天）
        async function renderDailyQuote(dateKey = null) {
            const card = document.getElementById('dailyQuoteCard');

            // 如果沒有指定日期，使用選中的日期，如果沒有選中則不顯示
            if (!dateKey && !selectedDate) {
                card.innerHTML = '';
                return;
            }

            const targetDateKey = dateKey || (selectedDate ? formatDateKey(selectedDate) : null);
            if (!targetDateKey) {
                card.innerHTML = '';
                return;
            }

            const quote = await getQuoteForDate(targetDateKey);
            const isUnlocked = checkDateUnlocked(targetDateKey);
            const isToday = targetDateKey === getTodayKey();

            if (quote) {
                // 已領取，顯示語錄和圖片（圖片作為背景）
                let imageSrc = '';
                let backgroundStyle = '';

                if (quote.image) {
                    // 判斷是 data URL 還是純 base64
                    imageSrc = quote.image.startsWith('data:')
                        ? quote.image
                        : `data:image/png;base64,${quote.image}`;
                    backgroundStyle = `background-image: url('${imageSrc}'); background-size: cover; background-position: center; background-repeat: no-repeat;`;
                }

                card.innerHTML = `
                    <div class="rounded-xl p-6 shadow-md mb-4 relative overflow-hidden min-h-[200px] flex flex-col justify-center" style="${backgroundStyle}">
                        <div class="relative z-10 bg-black bg-opacity-30 backdrop-blur-sm rounded-lg p-4">
                            <div class="flex items-center justify-between mb-3">
                                <div class="text-sm text-white font-semibold flex items-center drop-shadow-lg">
                                    <span class="mr-1">✨</span> ${targetDateKey}
                        </div>
                            </div>
                            <div class="text-white text-lg leading-relaxed whitespace-pre-line font-medium drop-shadow-lg">
                                ${escapeHtml(quote.quote)}
                            </div>
                        </div>
                    </div>
                `;
            } else if (isToday && !isUnlocked && !developerMode) {
                // 今天未解鎖（開發者模式下不顯示此提示）
                card.innerHTML = `
                    <div class="bg-gradient-to-br from-purple-50 to-pink-50 rounded-xl p-4 shadow-md border-l-4 border-purple-500 mb-4">
                        <div class="text-center py-2">
                            <p class="text-gray-600 mb-2 text-sm">今日還沒打卡</p>
                        </div>
                    </div>
                `;
            } else {
                // 沒有語錄時不顯示任何內容
                card.innerHTML = '';
            }
        }

        // 監聽語錄列表的更新（從管理頁面）
        window.addEventListener('storage', function(e) {
            if (e.key === 'dailyQuotes_list') {
                // 語錄列表已更新，重新加載
                // 注意：在同一個窗口/標籤頁內，storage 事件不會觸發
                // 所以我們使用自定義事件來通知
                const newQuotes = e.newValue ? JSON.parse(e.newValue) : [];
                console.log('語錄列表已更新，共', newQuotes.length, '條語錄');
            }
        });

        // 在同一個窗口內監聽自定義事件
        window.addEventListener('dailyQuotesUpdated', function() {
            // 重新獲取語錄列表（下次使用時會自動使用新的列表）
            console.log('語錄列表已更新');
        });

        // 初始化
        async function init() {
            // 先載入語錄數據
            await loadQuotesFromFile();
            dailyQuotes = dailyQuotesData; // 更新變數

            // 更新開發者模式指示器
            updateDeveloperModeIndicator();
            // 更新重置按鈕顯示狀態
            updateResetButtonVisibility();

            initUsers();
            renderCalendar();
            updateMonthYear();
            renderAllTodosList(); // 初始化時顯示所有待辦事項列表
            renderDailyQuote().catch(err => console.error('渲染語錄失敗:', err)); // 初始化每日語錄
            // 同步所有已解鎖的語錄到待辦事項
            syncAllQuotesToTodos().then(() => {
                renderCalendar();
                renderAllTodosList();
            });
        }

        // 更新月份年份顯示
        function updateMonthYear() {
            const monthYear = `${currentDate.getFullYear()} 年 ${monthNames[currentDate.getMonth()]}`;
            document.getElementById('currentMonthYear').textContent = monthYear;
        }

        // 渲染月曆
        function renderCalendar() {
            const calendarGrid = document.getElementById('calendarGrid');
            calendarGrid.innerHTML = '';

            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();

            // 當月第一天
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startingDayOfWeek = firstDay.getDay();

            // 填充空白（上個月的日期）
            for (let i = 0; i < startingDayOfWeek; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.className = 'calendar-day rounded-lg';
                calendarGrid.appendChild(emptyDay);
            }

            // 當月的日期
            const today = new Date();
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                const dateKey = formatDateKey(date);
                const dayElement = document.createElement('div');

                // 避免徽章/文字溢出月曆格子
                let classes = 'calendar-day relative overflow-hidden rounded-lg p-2 cursor-pointer border-2 border-transparent';

                const todayKey = getTodayKey();
                const isUnlocked = checkDateUnlocked(dateKey);

                // 檢查是否為今天
                if (isToday(date)) {
                    classes += ' today';
                }

                // 檢查是否有未完成的待辦事項
                const dateTodos = todos[dateKey] || [];
                const hasUncompletedTodos = dateTodos.some(todo => {
                    if (typeof todo === 'string') return true; // 舊格式視為未完成
                    // 檢查 status 或 completed/failed 屬性
                    if (todo.status) {
                        return todo.status === 'pending';
                    }
                    return !todo.completed && !todo.failed;
                });
                if (hasUncompletedTodos) {
                    classes += ' has-todos';
                }

                dayElement.className = classes;
                dayElement.onclick = () => selectDate(date);

                // 日期數字和 Today 標籤容器（同一行）
                const dayNumberContainer = document.createElement('div');
                // 手機：讓 Today 強制換到下一行（用 flex-wrap + Today 標籤 w-full）
                dayNumberContainer.className = 'flex flex-wrap items-center gap-1 mb-1';

                const dayNumber = document.createElement('div');
                dayNumber.className = 'font-semibold text-gray-800';
                dayNumber.textContent = day;
                dayNumberContainer.appendChild(dayNumber);

                // 普通模式：鎖圖標（只有當天且未解鎖時才顯示）
                // 需求：手機版「日期旁邊放鎖」
                if (!developerMode && dateKey === todayKey && !isUnlocked) {
                    const lockButton = document.createElement('button');
                    lockButton.className = 'inline-flex items-center justify-center text-gray-400 hover:text-gray-600 transition p-0.5 rounded ml-0.5';
                    lockButton.innerHTML = `
                        <svg class="w-3.5 h-3.5 sm:w-4 sm:h-4" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"/>
                        </svg>
                    `;
                    lockButton.onclick = (e) => {
                        e.stopPropagation(); // 阻止觸發日期選擇
                        openUnlockModal(dateKey, date);
                    };
                    dayNumberContainer.appendChild(lockButton);
                }

                // 今天的標籤
                // 手機：移到下一行（w-full）；sm 以上維持同一行
                if (isToday(date)) {
                    const todayLabel = document.createElement('div');
                    todayLabel.className = 'w-full sm:w-auto text-[10px] sm:text-xs bg-blue-500 text-white rounded-full px-1.5 sm:px-2 py-0.5 inline-block font-semibold whitespace-nowrap leading-none';
                    todayLabel.textContent = 'Today';
                    dayNumberContainer.appendChild(todayLabel);
                }

                dayElement.appendChild(dayNumberContainer);

                // 待辦事項數量標記（只計算未完成的）
                const uncompletedCount = dateTodos.filter(todo => {
                    if (typeof todo === 'string') return true; // 舊格式視為未完成
                    // 檢查 status 或 completed/failed 屬性
                    if (todo.status) {
                        return todo.status === 'pending';
                    }
                    return !todo.completed && !todo.failed;
                }).length;
                if (uncompletedCount > 0) {
                    const todoCount = document.createElement('div');
                    // 固定在格子右下角，避免擠壓內容/溢出
                    todoCount.className = 'absolute bottom-1 right-1 z-10 text-[10px] sm:text-xs bg-yellow-400 text-yellow-900 rounded-full px-1.5 sm:px-2 py-0.5 font-semibold whitespace-nowrap leading-none';
                    todoCount.textContent = uncompletedCount;
                    dayElement.appendChild(todoCount);
                }

                // 開發者模式：為所有日期添加快速打卡按鈕
                if (developerMode) {
                    // 使用同步版本檢查是否有語錄
                    const quote = getQuoteForDateSync(dateKey);
                    if (!quote) { // 如果還沒有語錄，顯示打卡按鈕
                        const devCheckinBtn = document.createElement('button');
                        devCheckinBtn.className = 'absolute top-1 right-1 p-1 text-green-500 hover:text-green-700 transition text-xs font-bold';
                        devCheckinBtn.innerHTML = '✓';
                        devCheckinBtn.title = '開發者模式：快速打卡';
                        devCheckinBtn.onclick = async (e) => {
                            e.stopPropagation();
                            // 顯示載入狀態
                            devCheckinBtn.disabled = true;
                            devCheckinBtn.innerHTML = '...';
                            try {
                                await devModeCheckin(dateKey);
                            } catch (error) {
                                console.error('打卡失敗:', error);
                                alert('打卡失敗，請重試');
                                devCheckinBtn.innerHTML = '✓';
                                devCheckinBtn.disabled = false;
                            }
                        };
                        dayElement.style.position = 'relative';
                        dayElement.appendChild(devCheckinBtn);
                    }
                }

                // 如果已解鎖，顯示打卡天數
                if (isUnlocked) {
                    // 計算這是第幾天打卡（統計所有已解鎖的日期中，這個日期是第幾個）
                    const unlockedDates = loadUnlockedDates();
                    unlockedDates.sort(); // 按日期排序
                    const dayIndex = unlockedDates.indexOf(dateKey);
                    if (dayIndex !== -1) {
                        const dayCountLabel = document.createElement('div');
                        // 固定在格子左下角，避免把格子高度撐開/溢出
                        dayCountLabel.className = 'absolute bottom-1 left-1 z-10 inline-flex items-center justify-center px-1.5 sm:px-2 py-0.5 sm:py-1 rounded-full bg-gradient-to-r from-purple-500 to-pink-500 text-white text-[10px] sm:text-xs font-bold shadow-md transform transition-transform hover:scale-105 whitespace-nowrap leading-none';
                        dayCountLabel.textContent = `第${dayIndex + 1}天`;
                        dayElement.appendChild(dayCountLabel);
                    }
                }

                // 儲存日期資訊到元素，方便後續查找
                dayElement.setAttribute('data-date-key', dateKey);
                dayElement.setAttribute('data-day', day);

                calendarGrid.appendChild(dayElement);
            }
        }

        // 選擇日期
        function selectDate(date) {
            selectedDate = date;
            const dateKey = formatDateKey(date);

            // 更新標題
            const dateStr = `${date.getFullYear()} 年 ${date.getMonth() + 1} 月 ${date.getDate()} 日`;
            const dayOfWeek = dayNames[date.getDay()];
            document.getElementById('selectedDateTitle').textContent = `${dateStr}（${dayOfWeek}）`;

            // 顯示該日期的語錄
            renderDailyQuote(dateKey).catch(err => console.error('渲染語錄失敗:', err));

            // 顯示待辦事項
            renderTodos(dateKey);

            // 顯示新增表單
            document.getElementById('addTodoForm').classList.remove('hidden');

            // 更新月曆選中狀態
            updateSelectedDay();
        }

        // 更新選中的日期樣式
        function updateSelectedDay() {
            // 移除所有選中樣式
            const allDays = document.querySelectorAll('.calendar-day');
            allDays.forEach(day => {
                day.classList.remove('ring-2', 'ring-blue-500', 'ring-offset-2');
            });

            // 為選中的日期添加藍色框
            if (selectedDate) {
                const selectedDateKey = formatDateKey(selectedDate);
                const selectedDayElement = document.querySelector(`[data-date-key="${selectedDateKey}"]`);

                if (selectedDayElement) {
                    selectedDayElement.classList.add('ring-2', 'ring-blue-500', 'ring-offset-2');
                }
            }
        }

        // 渲染待辦事項
        function renderTodos(dateKey) {
            const todoList = document.getElementById('todoList');
            const dateTodos = todos[dateKey] || [];

            if (dateTodos.length === 0) {
                todoList.innerHTML = '<p class="text-gray-400 text-sm text-center py-4">這一天沒有待辦事項</p>';
                return;
            }

            todoList.innerHTML = dateTodos.map((todo, index) => {
                // 支援舊格式（字串）和新格式（物件）
                const todoText = typeof todo === 'string' ? todo : todo.text;
                let status = 'pending'; // pending, completed, failed
                const isDailyQuote = typeof todo === 'object' && todo.isDailyQuote;

                if (typeof todo === 'object') {
                    // 新格式：使用 status 或 completed/failed 屬性
                    if (todo.status) {
                        status = todo.status;
                    } else if (todo.completed) {
                        status = 'completed';
                    } else if (todo.failed) {
                        status = 'failed';
                    }
                }

                const isCompleted = status === 'completed';
                const isFailed = status === 'failed';

                // 如果是每日語錄且有背景顏色，使用圖片顏色作為背景
                let styleAttr = '';
                let className = isCompleted ? 'completed' : isFailed ? 'failed' : 'bg-gray-50 border-gray-200';

                if (isDailyQuote && typeof todo === 'object' && todo.bgColor) {
                    // 使用圖片主色調作為背景
                    styleAttr = `style="background: ${todo.bgColor}; border-color: ${todo.bgColor};"`;
                    className = ''; // 不使用預設類別
                }

                return `
                    <div class="todo-item flex items-center gap-2 p-3 rounded-lg border ${className}" ${styleAttr}>
                        <!-- 完成按鈕（打勾） -->
                        <button onclick="markAsCompleted('${dateKey}', ${index})"
                                class="flex-shrink-0 p-1 ${isCompleted ? 'text-emerald-600' : 'text-gray-400'} hover:bg-gray-200 rounded transition"
                                title="標記為完成">
                            ${isCompleted ? `
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
                                </svg>
                            ` : `
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                            `}
                        </button>
                        <!-- 失敗按鈕（X） -->
                        <button onclick="markAsFailed('${dateKey}', ${index})"
                                class="flex-shrink-0 p-1 ${isFailed ? 'text-gray-500' : 'text-gray-400'} hover:bg-gray-200 rounded transition"
                                title="標記為失敗">
                            ${isFailed ? `
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
                                </svg>
                            ` : `
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            `}
                        </button>
                        <div class="flex-1 flex flex-col">
                            <span class="flex items-center gap-2 ${isFailed ? 'line-through text-gray-500' : isCompleted ? 'text-emerald-800 font-semibold' : 'text-gray-800'}">
                                ${isCompleted ? '<span class="text-lg">✨</span>' : ''}
                                ${escapeHtml(todoText)}
                                ${isCompleted ? '<span class="text-lg">🎉</span>' : ''}
                            </span>
                            ${isFailed ? '<span class="text-xs text-amber-700 mt-1 flex items-center gap-1">💪 你還是很棒</span>' : ''}
                        </div>
                        <!-- 刪除按鈕（垃圾桶） -->
                        <button onclick="removeTodo('${dateKey}', ${index})"
                                class="flex-shrink-0 p-1 text-red-600 hover:bg-red-100 rounded transition"
                                title="刪除">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    </div>
                `;
            }).join('');
        }

        // 渲染所有待辦事項日期列表
        function renderAllTodosList() {
            const allTodosContent = document.getElementById('allTodosContent');
            const allDatesWithTodos = Object.keys(todos).filter(dateKey => {
                const dateTodos = todos[dateKey] || [];
                // 只顯示有未完成待辦事項的日期
                return dateTodos.some(todo => {
                    if (typeof todo === 'string') return true; // 舊格式視為未完成
                    // 檢查 status 或 completed/failed 屬性
                    if (todo.status) {
                        return todo.status === 'pending';
                    }
                    return !todo.completed && !todo.failed;
                });
            });

            if (allDatesWithTodos.length === 0) {
                allTodosContent.innerHTML = '<p class="text-gray-400 text-sm text-center py-4">目前沒有待辦事項</p>';
                return;
            }

            // 按日期排序（最新的在前）
            allDatesWithTodos.sort((a, b) => b.localeCompare(a));

            allTodosContent.innerHTML = allDatesWithTodos.map(dateKey => {
                const date = parseDateKey(dateKey);
                const dateStr = `${date.getFullYear()} 年 ${date.getMonth() + 1} 月 ${date.getDate()} 日`;
                const dateTodos = todos[dateKey] || [];
                // 只計算未完成的待辦事項
                const uncompletedCount = dateTodos.filter(todo => {
                    if (typeof todo === 'string') return true; // 舊格式視為未完成
                    // 檢查 status 或 completed/failed 屬性
                    if (todo.status) {
                        return todo.status === 'pending';
                    }
                    return !todo.completed && !todo.failed;
                }).length;
                const dayOfWeek = dayNames[date.getDay()];

                return `
                    <div onclick="selectDateFromList('${dateKey}')"
                         class="flex items-center justify-between p-3 bg-gray-50 rounded-lg border border-gray-200 cursor-pointer hover:bg-gray-100 hover:border-blue-300 transition">
                        <div class="flex-1">
                            <div class="font-semibold text-gray-800 text-sm">${dateStr}（${dayOfWeek}）</div>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="bg-yellow-400 text-yellow-900 rounded-full px-2 py-1 text-xs font-bold">${uncompletedCount}</span>
                            <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                            </svg>
            </div>
    </div>
                `;
            }).join('');
        }

        // 從日期列表選擇日期
        function selectDateFromList(dateKey) {
            const date = parseDateKey(dateKey);
            selectDate(date);

            // 如果該日期不在當前顯示的月份，切換到該月份
            if (date.getFullYear() !== currentDate.getFullYear() ||
                date.getMonth() !== currentDate.getMonth()) {
                currentDate = new Date(date.getFullYear(), date.getMonth(), 1);
                renderCalendar();
                updateMonthYear();
            }

            updateSelectedDay();
        }

        // 解析日期 key 為 Date 物件
        function parseDateKey(dateKey) {
            const [year, month, day] = dateKey.split('-').map(Number);
            return new Date(year, month - 1, day);
        }

        // 新增待辦事項
        // 提取圖片主色調（使用 Canvas API）
        function extractDominantColor(imageBase64) {
            return new Promise((resolve) => {
                // 如果沒有圖片數據，直接返回預設顏色
                if (!imageBase64 || imageBase64.trim() === '') {
                    resolve('rgb(230, 200, 255)');
                    return;
                }

                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 100; // 縮小尺寸以提高性能
                    canvas.height = 100;
                    ctx.drawImage(img, 0, 0, 100, 100);

                    const imageData = ctx.getImageData(0, 0, 100, 100);
                    const data = imageData.data;

                    // 計算主要顏色（使用簡單的顏色聚類）
                    let r = 0, g = 0, b = 0;
                    let count = 0;

                    // 採樣部分像素點
                    for (let i = 0; i < data.length; i += 16) { // 每4個值代表一個像素，跳過16個值即每4個像素採樣一次
                        r += data[i];
                        g += data[i + 1];
                        b += data[i + 2];
                        count++;
                    }

                    r = Math.round(r / count);
                    g = Math.round(g / count);
                    b = Math.round(b / count);

                    // 轉換為 HSL 以調整亮度，確保背景不會太暗或太亮
                    const hsl = rgbToHsl(r, g, b);
                    // 增加亮度，讓背景更柔和
                    hsl.l = Math.min(95, Math.max(75, hsl.l + 20));
                    const adjustedRgb = hslToRgb(hsl.h, hsl.s, hsl.l);

                    resolve(`rgb(${adjustedRgb.r}, ${adjustedRgb.g}, ${adjustedRgb.b})`);
                };

                img.onerror = () => {
                    // 如果無法提取顏色，使用預設的紫色調
                    resolve('rgb(230, 200, 255)');
                };

                // 處理 base64 圖片
                try {
                    const imageSrc = imageBase64.startsWith('data:')
                        ? imageBase64
                        : `data:image/png;base64,${imageBase64}`;
                    img.src = imageSrc;
                } catch (error) {
                    // 如果設置 src 失敗，使用預設顏色
                    resolve('rgb(230, 200, 255)');
                }
            });
        }

        // RGB 轉 HSL
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        // HSL 轉 RGB
        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        // 將每日語錄加入到待辦事項中
        async function addDailyQuoteToTodos(dateKey, quote, imageBase64) {
            if (!todos[dateKey]) {
                todos[dateKey] = [];
            }

            // 檢查是否已經有這個語錄待辦事項（避免重複添加）
            const existingQuoteTodo = todos[dateKey].find(todo => {
                if (typeof todo === 'string') return false; // 字串格式不可能是語錄
                const text = todo.text;
                return todo.isDailyQuote === true && text === quote;
            });

            if (existingQuoteTodo) {
                return; // 已存在，不重複添加
            }

            // 提取圖片主色調
            const bgColor = await extractDominantColor(imageBase64);

            // 使用物件格式儲存待辦事項，標記為每日語錄
            todos[dateKey].push({
                text: quote,
                status: 'completed', // 自動標記為完成
                isDailyQuote: true, // 標記為每日語錄
                imageBase64: imageBase64, // 保存圖片用於提取顏色
                bgColor: bgColor // 保存提取的背景顏色
            });

            saveTodos();

            // 如果當前選中的是這個日期，立即更新顯示
            if (selectedDate && formatDateKey(selectedDate) === dateKey) {
                renderTodos(dateKey);
            }

            renderCalendar();
            renderAllTodosList();
        }

        function addTodo() {
            if (!selectedDate) {
                alert('請先選擇日期');
                return;
            }

            const input = document.getElementById('newTodoInput');
            const todoText = input.value.trim();

            if (!todoText) {
                alert('請輸入待辦事項');
                return;
            }

            const dateKey = formatDateKey(selectedDate);

            if (!todos[dateKey]) {
                todos[dateKey] = [];
            }

            // 使用物件格式儲存待辦事項
            todos[dateKey].push({ text: todoText, status: 'pending' });
            saveTodos();
            renderTodos(dateKey);
            renderCalendar();
            renderAllTodosList(); // 更新所有待辦事項列表
            input.value = '';
        }

        // 標記為完成（點擊第二次可取消）
        function markAsCompleted(dateKey, index) {
            if (todos[dateKey] && todos[dateKey][index] !== undefined) {
                const todo = todos[dateKey][index];
                let currentStatus = 'pending';

                // 判斷當前狀態
                if (typeof todo === 'object') {
                    if (todo.status) {
                        currentStatus = todo.status;
                    } else if (todo.completed) {
                        currentStatus = 'completed';
                    } else if (todo.failed) {
                        currentStatus = 'failed';
                    }
                }

                // 如果已經是完成狀態，點擊第二次則取消（變回未完成）
                if (currentStatus === 'completed') {
                    todos[dateKey][index] = {
                        text: typeof todo === 'string' ? todo : (todo.text || todo),
                        status: 'pending'
                    };
                } else {
                    // 否則標記為完成
                    todos[dateKey][index] = {
                        text: typeof todo === 'string' ? todo : (todo.text || todo),
                        status: 'completed'
                    };
                }

                saveTodos();
                renderTodos(dateKey);
                renderCalendar();
                renderAllTodosList(); // 更新所有待辦事項列表
            }
        }

        // 標記為失敗（點擊第二次可取消）
        function markAsFailed(dateKey, index) {
            if (todos[dateKey] && todos[dateKey][index] !== undefined) {
                const todo = todos[dateKey][index];
                let currentStatus = 'pending';

                // 判斷當前狀態
                if (typeof todo === 'object') {
                    if (todo.status) {
                        currentStatus = todo.status;
                    } else if (todo.completed) {
                        currentStatus = 'completed';
                    } else if (todo.failed) {
                        currentStatus = 'failed';
                    }
                }

                // 如果已經是失敗狀態，點擊第二次則取消（變回未完成）
                if (currentStatus === 'failed') {
                    todos[dateKey][index] = {
                        text: typeof todo === 'string' ? todo : (todo.text || todo),
                        status: 'pending'
                    };
                } else {
                    // 否則標記為失敗
                    todos[dateKey][index] = {
                        text: typeof todo === 'string' ? todo : (todo.text || todo),
                        status: 'failed'
                    };
                }

                saveTodos();
                renderTodos(dateKey);
                renderCalendar();
                renderAllTodosList(); // 更新所有待辦事項列表
            }
        }

        // 移除待辦事項
        function removeTodo(dateKey, index) {
            if (todos[dateKey] && todos[dateKey][index] !== undefined) {
                todos[dateKey].splice(index, 1);

                // 如果陣列為空，刪除該日期
                if (todos[dateKey].length === 0) {
                    delete todos[dateKey];
                }

                saveTodos();
                renderTodos(dateKey);
                renderCalendar();
                renderAllTodosList(); // 更新所有待辦事項列表
            }
        }

        // 切換月份
        function changeMonth(delta) {
            currentDate.setMonth(currentDate.getMonth() + delta);
            renderCalendar();
            updateMonthYear();
            // 如果選中的日期在新月份中，保持選中狀態
            if (selectedDate) {
                const selectedDateKey = formatDateKey(selectedDate);
                const selectedDayElement = document.querySelector(`[data-date-key="${selectedDateKey}"]`);
                if (selectedDayElement) {
                    updateSelectedDay();
                } else {
                    // 如果選中的日期不在當前月份，清除選中狀態
                    selectedDate = null;
                    document.getElementById('selectedDateTitle').textContent = '選擇日期';
                    document.getElementById('todoList').innerHTML = '<p class="text-gray-400 text-sm text-center py-8">請選擇日期查看待辦事項</p>';
                    document.getElementById('addTodoForm').classList.add('hidden');
                }
            }
        }

        // 格式化日期為 key (YYYY-MM-DD)
        function formatDateKey(date) {
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
        }

        // 檢查是否為今天
        function isToday(date) {
            const today = new Date();
            return date.getFullYear() === today.getFullYear() &&
                   date.getMonth() === today.getMonth() &&
                   date.getDate() === today.getDate();
        }

        // 儲存待辦事項到 localStorage
        function saveTodos() {
            saveUserTodos();
        }

        // HTML 轉義
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // 支援 Enter 鍵新增
        document.getElementById('newTodoInput')?.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addTodo();
            }
        });

        // 初始化
        init();
    </script>
</body>
<script src="shared-nav.js" defer></script>
<script>
    // 手動切換按鈕（可覆蓋自動判斷）：桌機/手機視覺模式
    (function () {
        const KEY = 'eveday_force_desktop';
        const TARGET_WIDTH = 1280;

        try {
            // 只在移動設備上顯示切換按鈕
            const isSmallScreen = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
            const ua = navigator.userAgent.toLowerCase();
            const mobileUA = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(ua);
            const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const isMobile = isSmallScreen && (mobileUA || hasTouch);

            if (!isMobile) return; // 桌面設備不顯示切換按鈕

            const meta = document.querySelector('meta[name="viewport"]');
            if (!meta) return;

            const getEnabled = () => localStorage.getItem(KEY) === 'true';
            const setEnabled = (v) => localStorage.setItem(KEY, v ? 'true' : 'false');

            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'fixed bottom-4 right-4 z-50 px-3 py-2 rounded-full shadow-lg bg-gray-900 text-white text-xs font-semibold opacity-90 hover:opacity-100';

            function refreshLabel() {
                btn.textContent = getEnabled() ? '切回手機版' : '切到桌機版';
            }

            btn.onclick = () => {
                const next = !getEnabled();
                setEnabled(next);
                // 重新載入讓 viewport 早期生效、版型更穩
                window.location.reload();
            };

            refreshLabel();
            document.body.appendChild(btn);
        } catch (_) {
            // ignore
        }
    })();
</script>
</html>

