<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>轉盤遊戲</title>
    <!-- 載入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // 設定 Tailwind 配置
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'Noto Sans TC', 'sans-serif'],
                    },
                    colors: {
                        'primary-buy': '#10b981', // Emerald green
                        'secondary-bad': '#ef4444', // Red
                        'accent-spin': '#fcd34d', // Amber
                    }
                }
            }
        }
    </script>
    <style>
        /* 確保 Canvas 居中且響應式 */
        #wheelCanvas {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 9999px; /* 圓形陰影 */
            transition: transform 4s cubic-bezier(0.2, 0.8, 0.2, 1); /* 緩慢啟動和減速的動畫曲線 */
        }

        /* 指針樣式 */
        .pointer {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 30px solid #374151; /* Dark gray triangle */
            z-index: 10;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 400px; /* 限制最大寬度 */
            margin: auto;
            aspect-ratio: 1 / 1; /* 保持正方形 */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">
    <!-- 頂部導航欄 -->
    <nav class="bg-white shadow-md">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center">
                    <h1 class="text-2xl font-bold text-gray-800">轉盤遊戲</h1>
                </div>
                <div class="flex items-center gap-4">
                    <a href="admin.html"
                       class="text-gray-600 hover:text-gray-800 px-3 py-2 rounded-md text-sm font-medium transition">
                        後台管理
                    </a>
                </div>
            </div>
        </div>
    </nav>

    <!-- 主內容區域 -->
    <main class="flex-grow bg-gray-50 flex flex-col items-center justify-center p-4 font-sans">
        <div class="max-w-xl w-full bg-white p-6 md:p-10 rounded-xl shadow-2xl">
            <div class="text-center mb-4">
                <h2 class="text-3xl font-bold text-gray-800">
                    買/不好 決定轉盤
                </h2>
            </div>
            <p class="text-center text-gray-600 mb-8">
                <span class="font-semibold text-primary-buy" id="visualInfo">表面上是 50% 買 / 50% 不好</span>，但實際上...
            </p>

            <!-- 轉盤和指針容器 -->
            <div class="canvas-container">
                <!-- 指針 (位於頂部中心) -->
                <div class="pointer"></div>

                <!-- 轉盤 Canvas -->
                <canvas id="wheelCanvas" width="400" height="400" class="w-full h-full"></canvas>
            </div>

            <!-- 旋轉按鈕和結果顯示 -->
            <div class="flex flex-col items-center mt-8 space-y-4">
                <button id="spinButton"
                        class="w-full md:w-auto px-10 py-4 text-xl font-bold text-gray-900 bg-accent-spin rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed border-b-4 border-yellow-700/50">
                    開始旋轉！
                </button>
                <div id="resultDisplay"
                     class="min-h-[50px] w-full text-center text-2xl font-extrabold text-gray-700 p-3 rounded-lg bg-gray-100 transition-all duration-500 shadow-inner">
                    按下按鈕開始
                </div>
            </div>
        </div>
    </main>

    <!-- 頁腳 -->
    <footer class="bg-white border-t">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
            <p class="text-center text-gray-500 text-sm">
                © 2024 轉盤遊戲 - 所有權利保留
            </p>
        </div>
    </footer>

    <script>
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        const spinButton = document.getElementById('spinButton');
        const resultDisplay = document.getElementById('resultDisplay');
        const visualInfo = document.getElementById('visualInfo');

        // 預設配置
        const defaultConfig = {
            segments: [
                { label: "買", color: '#10b981', visualPercent: 50, realPercent: 80 },
                { label: "不好", color: '#ef4444', visualPercent: 50, realPercent: 20 }
            ]
        };

        // 從 localStorage 載入配置
        function loadConfig() {
            const saved = localStorage.getItem('wheelConfig');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    console.error('載入配置失敗，使用預設值', e);
                }
            }
            return defaultConfig;
        }

        // 儲存配置
        function saveConfig(config) {
            localStorage.setItem('wheelConfig', JSON.stringify(config));
        }

        // 載入配置
        let config = loadConfig();
        let segments = [];

        // 更新視覺資訊顯示
        function updateVisualInfo() {
            const info = config.segments.map(s => `${s.label} ${s.visualPercent}%`).join(' / ');
            visualInfo.textContent = `表面上是 ${info}`;
        }

        // 初始化轉盤數據
        function initSegments() {
            segments = config.segments.map((seg, index) => {
                const degrees = (seg.visualPercent / 100) * 360;
                return {
                    label: seg.label,
                    color: seg.color,
                    degrees: degrees,
                    visualPercent: seg.visualPercent,
                    realPercent: seg.realPercent,
                    startAngleDeg: 0, // 起始角度（度數）
                    endAngleDeg: 0    // 結束角度（度數）
                };
            });

            // 計算每個扇區的起始和結束角度（度數，0度在右側3點鐘方向）
            let currentAngle = 0;
            segments.forEach(seg => {
                seg.startAngleDeg = currentAngle;
                seg.endAngleDeg = currentAngle + seg.degrees;
                currentAngle = seg.endAngleDeg;
            });

            updateVisualInfo();
        }

        const totalDegrees = 360;
        let currentRotation = 0; // 當前旋轉角度 (度)
        let isSpinning = false;

        // 初始化
        initSegments();

        // 繪製轉盤
        function drawWheel() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.95;

            segments.forEach(segment => {
                // 將度數轉換為弧度（Canvas arc 使用弧度）
                // 注意：Canvas 0度在右側（3點鐘方向），順時針為正
                const startAngleRad = (segment.startAngleDeg * Math.PI) / 180;
                const endAngleRad = (segment.endAngleDeg * Math.PI) / 180;

                // 繪製扇區
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngleRad, endAngleRad);
                ctx.closePath();
                ctx.fillStyle = segment.color;
                ctx.fill();

                // 繪製文字 (位於扇區中心)
                const textAngleRad = (startAngleRad + endAngleRad) / 2;
                const textRadius = radius * 0.75;
                const x = centerX + Math.cos(textAngleRad) * textRadius;
                const y = centerY + Math.sin(textAngleRad) * textRadius;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(textAngleRad + Math.PI / 2); // 旋轉文字使其垂直於半徑
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Noto Sans TC, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(segment.label, 0, 0);
                ctx.restore();
            });

            // 繪製中心圓
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.15, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 4;
            ctx.stroke();
        }

        // 初始化繪製
        drawWheel();

        /**
         * 根據真實機率選擇結果
         */
        function selectResultByRealProbability() {
            const random = Math.random() * 100; // 0-100
            let cumulative = 0;

            for (let i = 0; i < config.segments.length; i++) {
                cumulative += config.segments[i].realPercent;
                if (random <= cumulative) {
                    return i; // 返回選中的索引
                }
            }
            // 如果因為浮點數誤差沒選中，返回最後一個
            return config.segments.length - 1;
        }

        /**
         * 計算指定扇區的目標角度（指針指向該扇區中心）
         * Canvas 角度系統：0度在右側（3點鐘），順時針為正
         * 指針在頂部（-90度或270度，12點鐘方向）
         * 需要計算讓該扇區中心對準指針的旋轉角度
         */
        function calculateTargetAngle(segmentIndex) {
            const segment = segments[segmentIndex];
            // 扇區中心角度（度數，相對於右側3點鐘方向）
            const centerAngleDeg = (segment.startAngleDeg + segment.endAngleDeg) / 2;

            // Canvas 角度系統：0度在右側（3點鐘），順時針為正
            // 指針在頂部（12點鐘方向），對應 -90度（或270度）
            // 要讓扇區中心對準指針，需要將 centerAngleDeg 旋轉到 -90度位置

            // 計算：如果扇區中心在 centerAngleDeg（度數，0度在右側），
            // 要讓它對準頂部（-90度），需要旋轉的角度
            // 目標：centerAngleDeg + rotation = -90度
            // 所以：rotation = -90 - centerAngleDeg
            // 但 CSS rotate 是順時針，所以：rotation = 270 - centerAngleDeg
            let targetAngle = 270 - centerAngleDeg;

            // 標準化到 0-360 範圍
            while (targetAngle < 0) targetAngle += 360;
            while (targetAngle >= 360) targetAngle -= 360;

            return targetAngle;
        }

        /**
         * 執行旋轉動作，根據真實機率決定結果，但視覺上停在對應扇區
         */
        function spinWheel() {
            if (isSpinning) return;
            isSpinning = true;
            spinButton.disabled = true;
            resultDisplay.textContent = "轉盤高速旋轉中...";
            resultDisplay.className = "min-h-[50px] w-full text-center text-2xl font-extrabold text-white p-3 rounded-lg bg-gray-500 transition-all duration-500 shadow-inner";

            // 1. 根據真實機率選擇結果
            const selectedIndex = selectResultByRealProbability();
            const selectedSegment = segments[selectedIndex];

            // 2. 計算目標角度（讓選中的扇區中心對準指針）
            const baseTargetAngle = calculateTargetAngle(selectedIndex);

            // 3. 在扇區內添加一些隨機偏移，讓結果看起來更自然（但仍在該扇區內）
            const segmentRange = selectedSegment.degrees;
            const randomOffset = (Math.random() - 0.5) * segmentRange * 0.6; // 在扇區60%範圍內隨機
            const targetAngle = baseTargetAngle + randomOffset;

            // 4. 增加多個整圈旋轉 (讓旋轉看起來很長很隨機)
            const fullRotations = Math.floor(Math.random() * 5) + 6; // 6到10圈
            const totalDegreesToSpin = (fullRotations * totalDegrees) + targetAngle;

            // 5. 計算最終旋轉角度（從當前角度計算）
            const currentRotationInDegrees = currentRotation % totalDegrees;
            const degreesToGo = totalDegreesToSpin - currentRotationInDegrees;
            const finalRotation = currentRotation + degreesToGo;

            // 6. 設定 CSS Transform
            canvas.style.transform = `rotate(${finalRotation}deg)`;

            // 7. 旋轉動畫持續時間 (4 秒，必須與 CSS transition 保持一致)
            const duration = 4000;

            setTimeout(() => {
                isSpinning = false;
                spinButton.disabled = false;
                currentRotation = finalRotation % totalDegrees; // 更新當前角度

                // 8. 顯示結果
                showResult(selectedSegment.label, selectedSegment.color);

            }, duration);
        }

        function showResult(resultLabel, resultColor) {
            // 將 hex 顏色轉換為 RGB 用於背景
            const hex = resultColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);

            resultDisplay.textContent = `結果是... ${resultLabel}！`;
            resultDisplay.style.backgroundColor = `rgba(${r}, ${g}, ${b}, 0.9)`;
            resultDisplay.className = "min-h-[50px] w-full text-center text-2xl font-extrabold text-white p-3 rounded-lg transition-all duration-500 shadow-2xl";
        }

        // 監聽配置變化（當後台更新配置時）
        window.addEventListener('storage', (e) => {
            if (e.key === 'wheelConfig') {
                config = loadConfig();
                initSegments();
                drawWheel();
            }
        });

        // 定期檢查配置變化（同頁面內更新）
        setInterval(() => {
            const newConfig = loadConfig();
            if (JSON.stringify(newConfig) !== JSON.stringify(config)) {
                config = newConfig;
                initSegments();
                drawWheel();
            }
        }, 500);

        // 事件監聽
        spinButton.addEventListener('click', spinWheel);

        // 讓轉盤在視窗大小改變時保持正確的尺寸
        window.addEventListener('resize', () => {
            // 在這裡我們依賴 CSS W-full/H-full 和 aspect-ratio 來處理響應性，
            // 只需要重新繪製確保文字清晰。
            // 實際 Canvas 尺寸在 HTML 中固定為 400x400，但會被 CSS 縮放。
            // 為了簡化，我們只在初始化時繪製一次，如果需要更精確的響應式繪圖，
            // 則需要根據實際渲染大小調整 `canvas.width/height` 和繪圖參數。
        });

    </script>
</body>
</html>
